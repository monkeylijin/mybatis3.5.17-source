# ç¬¬5ç¯‡æ€è€ƒé¢˜è§£ç­”

## ğŸ“ ç¬¬4ç¯‡å›é¡¾æ€è€ƒé¢˜è§£ç­”

åœ¨æ·±å…¥å­¦ä¹ Executoræ‰§è¡Œå™¨ä½“ç³»ä¹‹å‰ï¼Œæˆ‘ä»¬å…ˆå›é¡¾å¹¶è§£ç­”ç¬¬4ç¯‡ä¸­æå‡ºçš„æ€è€ƒé¢˜ã€‚

### æ€è€ƒé¢˜1ï¼šä¸ºä»€ä¹ˆMyBatisé€‰æ‹©JDKåŠ¨æ€ä»£ç†è€Œéå­—èŠ‚ç å¢å¼ºï¼Ÿ

#### è¯¦ç»†è§£ç­”

**æŠ€æœ¯å±‚é¢åŸå› **ï¼š

1. **æ¥å£ä»£ç†çš„å¤©ç„¶ä¼˜åŠ¿**
   ```java
   // Mapperæ¥å£å¤©ç„¶é€‚åˆJDKåŠ¨æ€ä»£ç†
   public interface UserMapper {
       User findById(Long id);
       List<User> findAll();
   }
   
   // JDKåŠ¨æ€ä»£ç†åªéœ€è¦æ¥å£ï¼Œæ— éœ€å…·ä½“å®ç°ç±»
   UserMapper mapper = (UserMapper) Proxy.newProxyInstance(
       classLoader, 
       new Class[]{UserMapper.class}, 
       new MapperProxy<>(sqlSession, UserMapper.class, methodCache)
   );
   ```

2. **æ€§èƒ½è€ƒè™‘**
   - JDKåŠ¨æ€ä»£ç†åœ¨Java 8+ç‰ˆæœ¬ç»è¿‡ä¼˜åŒ–ï¼Œæ€§èƒ½ä¼˜å¼‚
   - å­—èŠ‚ç å¢å¼ºéœ€è¦é¢å¤–çš„åº“ä¾èµ–å’Œå¤æ‚çš„å­—èŠ‚ç æ“ä½œ
   - å¯¹äºMyBatisçš„ä½¿ç”¨åœºæ™¯ï¼ŒJDKåŠ¨æ€ä»£ç†çš„æ€§èƒ½å®Œå…¨å¤Ÿç”¨

3. **ç®€æ´æ€§å’Œç»´æŠ¤æ€§**
   ```java
   // MapperProxyå®ç°ç›¸å¯¹ç®€å•
   public class MapperProxy<T> implements InvocationHandler, Serializable {
       @Override
       public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
           // ç®€å•çš„æ–¹æ³•è°ƒç”¨è½¬å‘é€»è¾‘
           return mapperMethod.execute(sqlSession, args);
       }
   }
   ```

**ä¸Executorçš„å…³ç³»**ï¼š
- Mapperä»£ç†æœ€ç»ˆè°ƒç”¨SqlSessionçš„æ–¹æ³•
- SqlSessioné€šè¿‡Executoræ‰§è¡Œå…·ä½“çš„æ•°æ®åº“æ“ä½œ
- è¿™ç§è®¾è®¡ä¿æŒäº†èŒè´£çš„æ¸…æ™°åˆ†ç¦»

### æ€è€ƒé¢˜2ï¼šå¤šè¿”å›å€¼åœºæ™¯ä¸‹ï¼ŒMapperMethodå¦‚ä½•åŒºåˆ†é›†åˆã€æ¸¸æ ‡ä¸æ˜ å°„ç±»å‹ï¼Ÿ

#### è¯¦ç»†è§£ç­”

**è¿”å›ç±»å‹è¯†åˆ«æœºåˆ¶**ï¼š

```java
public class MapperMethod {
    private final MethodSignature method;
    
    public Object execute(SqlSession sqlSession, Object[] args) {
        Object result;
        switch (command.getType()) {
            case SELECT:
                if (method.returnsVoid() && method.hasResultHandler()) {
                    executeWithResultHandler(sqlSession, args);
                    result = null;
                } else if (method.returnsMany()) {
                    result = executeForMany(sqlSession, args);
                } else if (method.returnsMap()) {
                    result = executeForMap(sqlSession, args);
                } else if (method.returnsCursor()) {
                    result = executeForCursor(sqlSession, args);
                } else {
                    Object param = method.convertArgsToSqlCommandParam(args);
                    result = sqlSession.selectOne(command.getName(), param);
                }
                break;
            // ... å…¶ä»–case
        }
        return result;
    }
}
```

**ç±»å‹åˆ¤æ–­é€»è¾‘**ï¼š

```java
public static class MethodSignature {
    
    public boolean returnsMany() {
        return returnsCollection || returnsArray;
    }
    
    public boolean returnsMap() {
        return mapKey != null;
    }
    
    public boolean returnsCursor() {
        return Cursor.class.equals(returnType);
    }
    
    private boolean returnsCollection() {
        return Collection.class.isAssignableFrom(returnType);
    }
    
    private boolean returnsArray() {
        return returnType != null && returnType.isArray();
    }
}
```

**ä¸Executorçš„åä½œ**ï¼š
- MapperMethodæ ¹æ®è¿”å›ç±»å‹é€‰æ‹©ä¸åŒçš„SqlSessionæ–¹æ³•
- SqlSessionå°†è°ƒç”¨å§”æ‰˜ç»™ç›¸åº”çš„Executoræ–¹æ³•
- Executoræ ¹æ®ä¸åŒçš„æŸ¥è¯¢ç±»å‹é€‰æ‹©åˆé€‚çš„æ‰§è¡Œç­–ç•¥

### æ€è€ƒé¢˜3ï¼šäºŒçº§ç¼“å­˜å¤±æ•ˆçš„è§¦å‘å› ç´ æœ‰å“ªäº›ï¼Ÿ

#### è¯¦ç»†è§£ç­”

**ç¼“å­˜å¤±æ•ˆè§¦å‘å› ç´ **ï¼š

1. **flushCacheé…ç½®**
   ```xml
   <update id="updateUser" flushCache="true">
       UPDATE user SET name = #{name} WHERE id = #{id}
   </update>
   ```

2. **useCacheé…ç½®**
   ```xml
   <select id="findById" useCache="false">
       SELECT * FROM user WHERE id = #{id}
   </select>
   ```

3. **ResultHandlerä½¿ç”¨**
   ```java
   // ä½¿ç”¨ResultHandlerä¼šç»•è¿‡äºŒçº§ç¼“å­˜
   session.select("findUsers", parameter, new ResultHandler() {
       public void handleResult(ResultContext context) {
           // å¤„ç†ç»“æœ
       }
   });
   ```

4. **å­˜å‚¨è¿‡ç¨‹OUTå‚æ•°**
   ```java
   // CachingExecutorä¸­çš„æ£€æŸ¥é€»è¾‘
   private void ensureNoOutParams(MappedStatement ms, BoundSql boundSql) {
       if (ms.getStatementType() == StatementType.CALLABLE) {
           for (ParameterMapping parameterMapping : boundSql.getParameterMappings()) {
               if (parameterMapping.getMode() != ParameterMode.IN) {
                   throw new ExecutorException("Caching stored procedures with OUT params is not supported.");
               }
           }
       }
   }
   ```

5. **äº‹åŠ¡è¾¹ç•Œå½±å“**
   ```java
   // TransactionalCacheçš„äº‹åŠ¡æ§åˆ¶
   public class TransactionalCache implements Cache {
       private boolean clearOnCommit;
       private final Set<Object> entriesMissedInCache;
       
       @Override
       public void commit() {
           if (clearOnCommit) {
               delegate.clear();
           }
           flushPendingEntries();
           reset();
       }
   }
   ```

**Executorçš„ç¼“å­˜ç®¡ç†**ï¼š
- CachingExecutorè´Ÿè´£äºŒçº§ç¼“å­˜çš„ç®¡ç†
- é€šè¿‡TransactionalCacheManagerç¡®ä¿äº‹åŠ¡ä¸€è‡´æ€§
- BaseExecutorç®¡ç†ä¸€çº§ç¼“å­˜ï¼Œä¸äºŒçº§ç¼“å­˜é…åˆå·¥ä½œ

## ğŸ§  æœ¬ç¯‡æ ¸å¿ƒæ€è€ƒé¢˜

### æ€è€ƒé¢˜1ï¼šä¸ºä»€ä¹ˆMyBatisè¦è®¾è®¡å¤šç§Executorç±»å‹ï¼Ÿ

#### å‚è€ƒè§£ç­”

**è®¾è®¡åŸå› **ï¼š

1. **å•ä¸€èŒè´£åŸåˆ™**
   - æ¯ç§Executorä¸“æ³¨äºç‰¹å®šçš„æ‰§è¡Œåœºæ™¯
   - SimpleExecutorï¼šç®€å•ç›´æ¥çš„æ‰§è¡Œ
   - ReuseExecutorï¼šStatementé‡ç”¨ä¼˜åŒ–
   - BatchExecutorï¼šæ‰¹é‡æ“ä½œä¼˜åŒ–

2. **æ€§èƒ½ä¼˜åŒ–ç­–ç•¥**
   ```java
   // ä¸åŒæ‰§è¡Œå™¨é’ˆå¯¹ä¸åŒåœºæ™¯ä¼˜åŒ–
   public enum ExecutorType {
       SIMPLE,    // é€‚åˆä¸€èˆ¬æŸ¥è¯¢
       REUSE,     // é€‚åˆé‡å¤SQL
       BATCH      // é€‚åˆæ‰¹é‡æ“ä½œ
   }
   ```

3. **çµæ´»çš„é…ç½®é€‰æ‹©**
   - å¯ä»¥æ ¹æ®å…·ä½“ä¸šåŠ¡åœºæ™¯é€‰æ‹©æœ€é€‚åˆçš„æ‰§è¡Œå™¨
   - æ”¯æŒè¿è¡Œæ—¶åŠ¨æ€åˆ‡æ¢æ‰§è¡Œå™¨ç±»å‹

**è®¾è®¡ä¼˜åŠ¿**ï¼š
- é¿å…äº†å•ä¸€æ‰§è¡Œå™¨çš„å¤æ‚æ€§
- æä¾›äº†é’ˆå¯¹æ€§çš„æ€§èƒ½ä¼˜åŒ–
- ä¿æŒäº†ä»£ç çš„å¯ç»´æŠ¤æ€§

### æ€è€ƒé¢˜2ï¼šBaseExecutorçš„æ¨¡æ¿æ–¹æ³•æ¨¡å¼å¦‚ä½•å®ç°ï¼Ÿ

#### å‚è€ƒè§£ç­”

**æ¨¡æ¿æ–¹æ³•å®ç°**ï¼š

```java
public abstract class BaseExecutor implements Executor {
    
    // æ¨¡æ¿æ–¹æ³•ï¼šå®šä¹‰æ ‡å‡†æµç¨‹
    @Override
    public <E> List<E> query(MappedStatement ms, Object parameter, 
                            RowBounds rowBounds, ResultHandler resultHandler, 
                            CacheKey cacheKey, BoundSql boundSql) throws SQLException {
        // 1. å‰ç½®æ£€æŸ¥
        if (closed) {
            throw new ExecutorException("Executor was closed.");
        }
        
        // 2. ç¼“å­˜å¤„ç†
        if (queryStack == 0 && ms.isFlushCacheRequired()) {
            clearLocalCache();
        }
        
        List<E> list;
        try {
            queryStack++;
            // 3. å°è¯•ä»ç¼“å­˜è·å–
            list = resultHandler == null ? (List<E>) localCache.getObject(cacheKey) : null;
            if (list != null) {
                handleLocallyCachedOutputParameters(ms, cacheKey, parameter, boundSql);
            } else {
                // 4. è°ƒç”¨æŠ½è±¡æ–¹æ³•ï¼ˆå­ç±»å®ç°ï¼‰
                list = queryFromDatabase(ms, parameter, rowBounds, resultHandler, cacheKey, boundSql);
            }
        } finally {
            queryStack--;
        }
        
        // 5. åç½®å¤„ç†
        if (queryStack == 0) {
            // å»¶è¿ŸåŠ è½½å¤„ç†
            for (DeferredLoad deferredLoad : deferredLoads) {
                deferredLoad.load();
            }
            deferredLoads.clear();
            
            // è¯­å¥çº§ç¼“å­˜æ¸…ç†
            if (configuration.getLocalCacheScope() == LocalCacheScope.STATEMENT) {
                clearLocalCache();
            }
        }
        return list;
    }
    
    // æŠ½è±¡æ–¹æ³•ï¼šå­ç±»å®ç°å…·ä½“é€»è¾‘
    protected abstract <E> List<E> doQuery(MappedStatement ms, Object parameter, 
                                          RowBounds rowBounds, ResultHandler resultHandler, 
                                          BoundSql boundSql) throws SQLException;
}
```

**ä¼˜åŠ¿åˆ†æ**ï¼š
- **ç»Ÿä¸€æµç¨‹**ï¼šæ‰€æœ‰æ‰§è¡Œå™¨éµå¾ªç›¸åŒçš„æ‰§è¡Œæµç¨‹
- **ç¼“å­˜ç®¡ç†**ï¼šåœ¨åŸºç±»ç»Ÿä¸€å¤„ç†ç¼“å­˜é€»è¾‘
- **æ‰©å±•æ€§**ï¼šå­ç±»åªéœ€å…³æ³¨å…·ä½“çš„æ‰§è¡Œé€»è¾‘
- **ä»£ç å¤ç”¨**ï¼šé¿å…äº†é‡å¤çš„æµç¨‹ä»£ç 

### æ€è€ƒé¢˜3ï¼šCachingExecutorçš„è£…é¥°å™¨æ¨¡å¼å¦‚ä½•å·¥ä½œï¼Ÿ

#### å‚è€ƒè§£ç­”

**è£…é¥°å™¨æ¨¡å¼å®ç°**ï¼š

```java
public class CachingExecutor implements Executor {
    private final Executor delegate;  // è¢«è£…é¥°çš„æ‰§è¡Œå™¨
    private final TransactionalCacheManager tcm = new TransactionalCacheManager();
    
    public CachingExecutor(Executor delegate) {
        this.delegate = delegate;
        delegate.setExecutorWrapper(this);
    }
    
    @Override
    public <E> List<E> query(MappedStatement ms, Object parameterObject, 
                            RowBounds rowBounds, ResultHandler resultHandler, 
                            CacheKey key, BoundSql boundSql) throws SQLException {
        Cache cache = ms.getCache();
        if (cache != null) {
            flushCacheIfRequired(ms);
            if (ms.isUseCache() && resultHandler == null) {
                ensureNoOutParams(ms, boundSql);
                @SuppressWarnings("unchecked")
                List<E> list = (List<E>) tcm.getObject(cache, key);
                if (list == null) {
                    // å§”æ‰˜ç»™è¢«è£…é¥°çš„æ‰§è¡Œå™¨
                    list = delegate.query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);
                    tcm.putObject(cache, key, list);
                }
                return list;
            }
        }
        // æ²¡æœ‰ç¼“å­˜æ—¶ç›´æ¥å§”æ‰˜
        return delegate.query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);
    }
    
    // å…¶ä»–æ–¹æ³•ä¹Ÿéƒ½å§”æ‰˜ç»™delegate
    @Override
    public int update(MappedStatement ms, Object parameterObject) throws SQLException {
        flushCacheIfRequired(ms);
        return delegate.update(ms, parameterObject);
    }
}
```

**å·¥ä½œæœºåˆ¶**ï¼š
1. **é€æ˜ä»£ç†**ï¼šå¯¹è°ƒç”¨è€…å®Œå…¨é€æ˜ï¼Œæ¥å£ä¸€è‡´
2. **åŠŸèƒ½å¢å¼º**ï¼šåœ¨åŸæœ‰åŠŸèƒ½åŸºç¡€ä¸Šå¢åŠ ç¼“å­˜èƒ½åŠ›
3. **çµæ´»ç»„åˆ**ï¼šå¯ä»¥è£…é¥°ä»»æ„ç±»å‹çš„åŸºç¡€æ‰§è¡Œå™¨
4. **èŒè´£åˆ†ç¦»**ï¼šç¼“å­˜é€»è¾‘ä¸æ‰§è¡Œé€»è¾‘åˆ†ç¦»

**ä¸ä¸€çº§ç¼“å­˜çš„åŒºåˆ«**ï¼š

| ç‰¹æ€§ | ä¸€çº§ç¼“å­˜ | äºŒçº§ç¼“å­˜ |
|------|---------|---------|
| **ä½œç”¨åŸŸ** | SqlSessionçº§åˆ« | Namespaceçº§åˆ« |
| **ç”Ÿå‘½å‘¨æœŸ** | ä¼šè¯çº§åˆ« | åº”ç”¨çº§åˆ« |
| **å®ç°ä½ç½®** | BaseExecutor | CachingExecutor |
| **é»˜è®¤çŠ¶æ€** | é»˜è®¤å¼€å¯ | éœ€è¦é…ç½®å¼€å¯ |
| **äº‹åŠ¡ç›¸å…³** | éšä¼šè¯ç»“æŸæ¸…ç† | éœ€è¦äº‹åŠ¡æäº¤æ‰ç”Ÿæ•ˆ |

### æ€è€ƒé¢˜4ï¼šBatchExecutoræ‰¹é‡æ“ä½œçš„ä¼˜åŠ¿å’Œæ³¨æ„äº‹é¡¹ï¼Ÿ

#### å‚è€ƒè§£ç­”

**æ‰¹é‡æ“ä½œä¼˜åŠ¿**ï¼š

1. **å‡å°‘ç½‘ç»œå¾€è¿”**
   ```java
   // æ™®é€šæ‰§è¡Œå™¨ï¼šæ¯æ¬¡æ“ä½œéƒ½éœ€è¦ç½‘ç»œå¾€è¿”
   for (User user : users) {
       mapper.insertUser(user); // Næ¬¡ç½‘ç»œå¾€è¿”
   }
   
   // æ‰¹é‡æ‰§è¡Œå™¨ï¼šæ‰¹é‡æäº¤å‡å°‘ç½‘ç»œå¾€è¿”
   for (User user : users) {
       mapper.insertUser(user); // æš‚å­˜åœ¨å†…å­˜
   }
   session.flushStatements(); // ä¸€æ¬¡æ€§æäº¤
   ```

2. **æ•°æ®åº“ä¼˜åŒ–**
   - æ•°æ®åº“å¯ä»¥æ‰¹é‡å¤„ç†å¤šä¸ªç›¸åŒç»“æ„çš„SQL
   - å‡å°‘SQLè§£æå’Œæ‰§è¡Œè®¡åˆ’ç”Ÿæˆçš„å¼€é”€
   - æé«˜æ•°æ®åº“çš„å¤„ç†æ•ˆç‡

3. **äº‹åŠ¡ä¼˜åŒ–**
   - æ‰€æœ‰æ“ä½œåœ¨åŒä¸€ä¸ªäº‹åŠ¡ä¸­å®Œæˆ
   - å‡å°‘äº‹åŠ¡å¼€å¯å’Œæäº¤çš„å¼€é”€

**ä½¿ç”¨æ³¨æ„äº‹é¡¹**ï¼š

1. **å¿…é¡»è°ƒç”¨flushStatements()**
   ```java
   try (SqlSession session = factory.openSession(ExecutorType.BATCH)) {
       UserMapper mapper = session.getMapper(UserMapper.class);
       
       for (User user : users) {
           mapper.insertUser(user);
       }
       
       // å¿…é¡»è°ƒç”¨ï¼Œå¦åˆ™æ“ä½œä¸ä¼šæ‰§è¡Œ
       session.flushStatements();
       session.commit();
   }
   ```

2. **å¼‚å¸¸å¤„ç†å¤æ‚**
   ```java
   try {
       List<BatchResult> results = session.flushStatements();
   } catch (BatchUpdateException e) {
       // éœ€è¦å¤„ç†æ‰¹é‡æ›´æ–°å¼‚å¸¸
       int[] updateCounts = e.getUpdateCounts();
       // åˆ†æå“ªäº›æ“ä½œæˆåŠŸï¼Œå“ªäº›å¤±è´¥
   }
   ```

3. **å†…å­˜ä½¿ç”¨è€ƒè™‘**
   - æ‰¹é‡æ“ä½œä¼šåœ¨å†…å­˜ä¸­ç´¯ç§¯SQLå’Œå‚æ•°
   - æ•°æ®é‡è¿‡å¤§å¯èƒ½å¯¼è‡´å†…å­˜æº¢å‡º
   - éœ€è¦é€‚å½“æ§åˆ¶æ‰¹æ¬¡å¤§å°

**æœ€ä½³å®è·µ**ï¼š
```java
public void batchInsertUsers(List<User> users) {
    final int BATCH_SIZE = 1000;
    
    try (SqlSession session = factory.openSession(ExecutorType.BATCH)) {
        UserMapper mapper = session.getMapper(UserMapper.class);
        
        for (int i = 0; i < users.size(); i++) {
            mapper.insertUser(users.get(i));
            
            // æ¯1000æ¡æäº¤ä¸€æ¬¡
            if (i % BATCH_SIZE == 0 || i == users.size() - 1) {
                session.flushStatements();
                session.commit();
            }
        }
    }
}
```

## ğŸ’¡ æ·±åº¦æ€è€ƒé¢˜

### é«˜çº§æ€è€ƒé¢˜1ï¼šå¦‚ä½•è®¾è®¡ä¸€ä¸ªæ”¯æŒè¯»å†™åˆ†ç¦»çš„Executorï¼Ÿ

#### æ€è·¯æç¤º
- è€ƒè™‘è£…é¥°å™¨æ¨¡å¼çš„åº”ç”¨
- å¦‚ä½•åˆ¤æ–­SQLæ˜¯è¯»æ“ä½œè¿˜æ˜¯å†™æ“ä½œ
- å¦‚ä½•ç®¡ç†å¤šä¸ªæ•°æ®æº
- äº‹åŠ¡ä¸€è‡´æ€§å¦‚ä½•ä¿è¯

### é«˜çº§æ€è€ƒé¢˜2ï¼šExecutorçš„æ’ä»¶æœºåˆ¶å¦‚ä½•å®ç°ï¼Ÿ

#### æ€è·¯æç¤º
- ç†è§£MyBatisçš„æ’ä»¶æ‹¦æˆªåŸç†
- Executorçš„å“ªäº›æ–¹æ³•å¯ä»¥è¢«æ‹¦æˆª
- å¦‚ä½•å®ç°ä¸€ä¸ªSQLæ€§èƒ½ç›‘æ§æ’ä»¶
- æ’ä»¶çš„æ‰§è¡Œé¡ºåºå¦‚ä½•æ§åˆ¶

### é«˜çº§æ€è€ƒé¢˜3ï¼šå¦‚ä½•ä¼˜åŒ–Executorçš„ç¼“å­˜ç­–ç•¥ï¼Ÿ

#### æ€è·¯æç¤º
- ä¸€çº§ç¼“å­˜çš„ä½œç”¨åŸŸæ˜¯å¦å¯ä»¥è°ƒæ•´
- äºŒçº§ç¼“å­˜çš„è¿‡æœŸç­–ç•¥å¦‚ä½•æ”¹è¿›
- å¦‚ä½•å®ç°åˆ†å¸ƒå¼ç¼“å­˜æ”¯æŒ
- ç¼“å­˜å‘½ä¸­ç‡å¦‚ä½•ç›‘æ§å’Œä¼˜åŒ–

---

**è¿™äº›æ€è€ƒé¢˜å°†å¸®åŠ©ä½ æ›´æ·±å…¥åœ°ç†è§£Executoræ‰§è¡Œå™¨ä½“ç³»çš„è®¾è®¡ç²¾é«“ï¼** ğŸ§ 