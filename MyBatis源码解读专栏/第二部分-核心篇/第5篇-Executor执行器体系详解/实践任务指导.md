# 第5篇实践任务指导

## 🎯 实践目标

通过动手实践，深入理解不同Executor的工作原理和适用场景，培养源码调试和性能分析能力。

## 📋 必做实践任务

### 实践1：Executor性能对比测试

#### 任务目标
对比SimpleExecutor、ReuseExecutor、BatchExecutor在不同场景下的性能表现

#### 实践步骤

**步骤1：准备测试环境**

```java
package com.example.executor.test;

import org.apache.ibatis.session.ExecutorType;
import org.apache.ibatis.session.SqlSession;
import org.apache.ibatis.session.SqlSessionFactory;

public class ExecutorPerformanceTest {
    
    private SqlSessionFactory sqlSessionFactory;
    private final int ITERATION_COUNT = 1000;
    
    public void setUp() {
        // 初始化SqlSessionFactory
        // 准备测试数据
    }
    
    /**
     * 测试SimpleExecutor性能
     */
    public void testSimpleExecutorPerformance() {
        long startTime = System.currentTimeMillis();
        
        try (SqlSession session = sqlSessionFactory.openSession(ExecutorType.SIMPLE)) {
            UserMapper mapper = session.getMapper(UserMapper.class);
            
            // 执行1000次相同查询
            for (int i = 0; i < ITERATION_COUNT; i++) {
                User user = mapper.findById(1L);
            }
        }
        
        long endTime = System.currentTimeMillis();
        System.out.println("SimpleExecutor执行" + ITERATION_COUNT + "次查询耗时: " + 
                          (endTime - startTime) + "ms");
    }
    
    /**
     * 测试ReuseExecutor性能
     */
    public void testReuseExecutorPerformance() {
        // TODO: 实现ReuseExecutor性能测试
        // 对比与SimpleExecutor的性能差异
    }
    
    /**
     * 测试BatchExecutor性能
     */
    public void testBatchExecutorPerformance() {
        // TODO: 实现BatchExecutor批量插入性能测试
        // 对比单条插入与批量插入的性能差异
    }
}
```

**步骤2：实现测试方法**
- 完成ReuseExecutor和BatchExecutor的性能测试
- 记录不同执行器的执行时间
- 分析性能差异的原因

**步骤3：结果分析**
- 制作性能对比表格
- 分析不同场景下的最优选择
- 总结执行器选择的最佳实践

#### 预期结果
- 理解不同执行器的性能特点
- 掌握性能测试的方法
- 能够根据场景选择合适的执行器

### 实践2：一级缓存机制分析

#### 任务目标
深入理解BaseExecutor的一级缓存工作原理

#### 实践步骤

**步骤1：缓存命中测试**

```java
package com.example.executor.cache;

public class FirstLevelCacheTest {
    
    /**
     * 测试相同参数查询的缓存命中
     */
    public void testSameParameterCacheHit() {
        try (SqlSession session = sqlSessionFactory.openSession()) {
            UserMapper mapper = session.getMapper(UserMapper.class);
            
            System.out.println("=== 第一次查询 ===");
            User user1 = mapper.findById(1L);
            
            System.out.println("=== 第二次查询（相同参数）===");
            User user2 = mapper.findById(1L);
            
            // 验证是否从缓存获取
            System.out.println("是否为同一对象: " + (user1 == user2));
        }
    }
    
    /**
     * 测试不同参数查询的缓存行为
     */
    public void testDifferentParameterCache() {
        // TODO: 实现不同参数的缓存测试
    }
    
    /**
     * 测试UPDATE操作对缓存的影响
     */
    public void testUpdateClearCache() {
        // TODO: 实现UPDATE操作缓存清理测试
    }
}
```

**步骤2：CacheKey生成分析**
- 在`BaseExecutor.createCacheKey()`方法设置断点
- 观察CacheKey的生成过程
- 分析影响CacheKey的因素

**步骤3：缓存失效场景测试**
- 测试UPDATE/INSERT/DELETE操作对缓存的影响
- 测试不同SqlSession的缓存隔离
- 测试flushCache配置的作用

#### 预期结果
- 深入理解一级缓存的工作机制
- 掌握CacheKey的生成规则
- 了解缓存失效的各种场景

### 实践3：BatchExecutor批量操作实践

#### 任务目标
掌握BatchExecutor的正确使用方法和注意事项

#### 实践步骤

**步骤1：批量插入实现**

```java
package com.example.executor.batch;

public class BatchExecutorPractice {
    
    /**
     * 使用BatchExecutor进行批量插入
     */
    public void batchInsertUsers() {
        try (SqlSession session = sqlSessionFactory.openSession(ExecutorType.BATCH)) {
            UserMapper mapper = session.getMapper(UserMapper.class);
            
            // 批量插入1000条数据
            for (int i = 1; i <= 1000; i++) {
                User user = new User();
                user.setName("User" + i);
                user.setEmail("user" + i + "@example.com");
                mapper.insertUser(user);
            }
            
            // 执行批量操作
            List<BatchResult> results = session.flushStatements();
            session.commit();
            
            // 分析批量结果
            for (BatchResult result : results) {
                System.out.println("SQL: " + result.getSql());
                System.out.println("参数数量: " + result.getParameterObjects().size());
                System.out.println("更新计数: " + Arrays.toString(result.getUpdateCounts()));
            }
        }
    }
    
    /**
     * 对比单条插入与批量插入的性能
     */
    public void compareSingleVsBatchInsert() {
        // TODO: 实现单条插入与批量插入的性能对比
    }
    
    /**
     * 测试批量操作的异常处理
     */
    public void testBatchExceptionHandling() {
        // TODO: 实现批量操作异常处理测试
    }
}
```

**步骤2：性能对比分析**
- 实现单条插入的性能测试
- 对比单条插入与批量插入的执行时间
- 分析不同数据量下的性能差异

**步骤3：异常处理研究**
- 故意插入重复数据引发异常
- 观察BatchUpdateException的处理
- 学习批量操作的异常恢复策略

#### 预期结果
- 掌握BatchExecutor的正确使用方法
- 理解批量操作的性能优势
- 学会处理批量操作的异常情况

### 实践4：CachingExecutor装饰器分析

#### 任务目标
理解CachingExecutor的装饰器模式实现和二级缓存机制

#### 实践步骤

**步骤1：二级缓存配置**

```xml
<!-- mybatis-config.xml -->
<configuration>
    <settings>
        <setting name="cacheEnabled" value="true"/>
    </settings>
</configuration>
```

```xml
<!-- UserMapper.xml -->
<mapper namespace="com.example.mapper.UserMapper">
    <cache />
    
    <select id="findById" resultType="User" useCache="true">
        SELECT * FROM user WHERE id = #{id}
    </select>
</mapper>
```

**步骤2：二级缓存行为测试**

```java
package com.example.executor.cache;

public class SecondLevelCacheTest {
    
    /**
     * 测试跨会话的二级缓存
     */
    public void testCrossSessionCache() {
        // 第一个会话
        try (SqlSession session1 = sqlSessionFactory.openSession()) {
            UserMapper mapper1 = session1.getMapper(UserMapper.class);
            User user1 = mapper1.findById(1L);
            session1.commit(); // 提交后才会写入二级缓存
        }
        
        // 第二个会话
        try (SqlSession session2 = sqlSessionFactory.openSession()) {
            UserMapper mapper2 = session2.getMapper(UserMapper.class);
            User user2 = mapper2.findById(1L); // 应该从二级缓存获取
        }
    }
    
    /**
     * 测试UPDATE操作对二级缓存的影响
     */
    public void testUpdateAffectSecondCache() {
        // TODO: 实现UPDATE操作对二级缓存影响的测试
    }
}
```

**步骤3：装饰器模式分析**
- 在`CachingExecutor.query()`方法设置断点
- 观察装饰器如何委托给基础执行器
- 分析TransactionalCacheManager的作用

#### 预期结果
- 理解装饰器模式在CachingExecutor中的应用
- 掌握二级缓存的配置和使用
- 了解事务缓存的管理机制

## 🔧 选做实践任务

### 实践5：自定义性能监控执行器

#### 任务目标
通过拦截器机制实现SQL执行性能监控

#### 实践步骤

**步骤1：实现性能监控拦截器**

```java
package com.example.executor.monitor;

@Intercepts({
    @Signature(type = Executor.class, method = "update", args = {MappedStatement.class, Object.class}),
    @Signature(type = Executor.class, method = "query", args = {MappedStatement.class, Object.class, RowBounds.class, ResultHandler.class})
})
public class PerformanceMonitorInterceptor implements Interceptor {
    
    private long slowQueryThreshold = 1000; // 慢查询阈值
    
    @Override
    public Object intercept(Invocation invocation) throws Throwable {
        long startTime = System.currentTimeMillis();
        Object result = invocation.proceed();
        long endTime = System.currentTimeMillis();
        long executionTime = endTime - startTime;
        
        MappedStatement ms = (MappedStatement) invocation.getArgs()[0];
        String methodName = invocation.getMethod().getName();
        
        // 记录执行信息
        logExecutionInfo(ms, methodName, executionTime);
        
        // 慢查询报警
        if (executionTime > slowQueryThreshold) {
            logSlowQuery(ms, methodName, executionTime);
        }
        
        return result;
    }
    
    private void logExecutionInfo(MappedStatement ms, String methodName, long executionTime) {
        // TODO: 实现执行信息记录
    }
    
    private void logSlowQuery(MappedStatement ms, String methodName, long executionTime) {
        // TODO: 实现慢查询报警
    }
}
```

### 实践6：执行器源码调试实验

#### 任务目标
通过源码调试深入理解执行器的工作流程

#### 关键断点设置
1. `BaseExecutor.query()` - 查询入口
2. `BaseExecutor.createCacheKey()` - 缓存键生成
3. `SimpleExecutor.doQuery()` - 简单查询执行
4. `ReuseExecutor.prepareStatement()` - Statement重用
5. `BatchExecutor.doUpdate()` - 批量更新
6. `CachingExecutor.query()` - 二级缓存查询

#### 调试任务
- 跟踪一次完整的查询流程
- 观察缓存的读写过程
- 分析Statement的创建和重用
- 研究批量操作的执行机制

## 📊 实践成果记录

### 性能测试结果表

| 测试场景 | SimpleExecutor | ReuseExecutor | BatchExecutor | 说明 |
|---------|---------------|---------------|---------------|------|
| 1000次相同查询 | ___ ms | ___ ms | N/A | |
| 1000次不同查询 | ___ ms | ___ ms | N/A | |
| 1000条单独插入 | ___ ms | ___ ms | ___ ms | |
| 1000条批量插入 | N/A | N/A | ___ ms | |

### 缓存命中率统计

| 测试场景 | 一级缓存命中率 | 二级缓存命中率 | 备注 |
|---------|---------------|---------------|------|
| 相同会话重复查询 | __% | __% | |
| 跨会话查询 | __% | __% | |
| 更新后查询 | __% | __% | |

### 问题与发现记录

1. **发现**: ________________
   **分析**: ________________
   **结论**: ________________

2. **问题**: ________________
   **解决**: ________________
   **启示**: ________________

## 💡 实践技巧

### 调试技巧
1. **设置条件断点**: 只在特定条件下暂停
2. **观察表达式**: 实时查看变量值变化
3. **调用栈分析**: 理解方法调用关系
4. **内存使用监控**: 观察对象创建和GC情况

### 性能测试技巧
1. **预热**: 先执行几次预热再正式测试
2. **多轮测试**: 执行多轮取平均值
3. **GC控制**: 测试前手动触发GC
4. **隔离测试**: 每个测试使用独立的环境

### 日志配置技巧
```xml
<!-- logback.xml -->
<configuration>
    <logger name="com.example.executor" level="DEBUG"/>
    <logger name="org.apache.ibatis.executor" level="DEBUG"/>
    <logger name="java.sql" level="DEBUG"/>
</configuration>
```

## 🎯 实践总结模板

### 完成实践后，请填写以下总结：

#### 最大收获
```
请描述通过实践获得的最重要的认知...
```

#### 遇到的挑战
```
请描述实践过程中遇到的主要困难和解决方法...
```

#### 性能优化启示
```
请总结对于Executor性能优化的理解和建议...
```

#### 源码理解深化
```
请描述通过调试源码加深了哪些理解...
```

---

**通过这些实践任务，你将深入掌握Executor执行器体系的精髓！** 🚀