# StatementHandlerè¯­å¥å¤„ç†å™¨å®è·µä»»åŠ¡æŒ‡å¯¼

## ğŸ¯ å®è·µç›®æ ‡

é€šè¿‡ä»¥ä¸‹å®è·µä»»åŠ¡ï¼Œä½ å°†èƒ½å¤Ÿï¼š
1. æ·±å…¥ç†è§£StatementHandlerçš„å·¥ä½œæœºåˆ¶
2. æŒæ¡ä¸åŒStatementHandlerçš„ä½¿ç”¨åœºæ™¯
3. å­¦ä¼šè°ƒè¯•å’Œç›‘æ§StatementHandlerçš„æ‰§è¡Œè¿‡ç¨‹
4. å…·å¤‡è‡ªå®šä¹‰StatementHandlerçš„å¼€å‘èƒ½åŠ›
5. ç†è§£StatementHandleråœ¨MyBatisæ¶æ„ä¸­çš„ä½œç”¨

## ğŸ“‹ ä»»åŠ¡æ¸…å•

### ä»»åŠ¡1ï¼šStatementHandleræ‰§è¡Œæµç¨‹è·Ÿè¸ªï¼ˆåŸºç¡€ï¼‰
**éš¾åº¦**: â­â­  
**é¢„è®¡ç”¨æ—¶**: 30åˆ†é’Ÿ  
**å­¦ä¹ ç›®æ ‡**: ç†è§£StatementHandlerçš„åŸºæœ¬æ‰§è¡Œæµç¨‹

#### ä»»åŠ¡æè¿°
é€šè¿‡è°ƒè¯•å™¨è·Ÿè¸ªStatementHandlerä»åˆ›å»ºåˆ°æ‰§è¡Œçš„å®Œæ•´æµç¨‹ï¼Œè§‚å¯Ÿä¸åŒç±»å‹StatementHandlerçš„è¡Œä¸ºå·®å¼‚ã€‚

#### å®è·µæ­¥éª¤

1. **å‡†å¤‡æµ‹è¯•ç¯å¢ƒ**
```xml
<!-- mybatis-config.xml -->
<configuration>
    <settings>
        <setting name="logImpl" value="STDOUT_LOGGING"/>
        <setting name="defaultStatementType" value="PREPARED"/>
    </settings>
    
    <environments default="development">
        <environment id="development">
            <transactionManager type="JDBC"/>
            <dataSource type="POOLED">
                <property name="driver" value="com.mysql.cj.jdbc.Driver"/>
                <property name="url" value="jdbc:mysql://localhost:3306/test"/>
                <property name="username" value="root"/>
                <property name="password" value="password"/>
            </dataSource>
        </environment>
    </environments>
    
    <mappers>
        <mapper resource="UserMapper.xml"/>
    </mappers>
</configuration>
```

2. **åˆ›å»ºæµ‹è¯•ç”¨ä¾‹**
```java
public class StatementHandlerTest {
    
    private SqlSessionFactory sessionFactory;
    
    @Before
    public void setup() throws IOException {
        String resource = "mybatis-config.xml";
        InputStream inputStream = Resources.getResourceAsStream(resource);
        sessionFactory = new SqlSessionFactoryBuilder().build(inputStream);
    }
    
    @Test
    public void testPreparedStatementHandler() {
        try (SqlSession session = sessionFactory.openSession()) {
            UserMapper mapper = session.getMapper(UserMapper.class);
            
            // åœ¨è¿™é‡Œè®¾ç½®æ–­ç‚¹ï¼Œè·Ÿè¸ªStatementHandlerçš„åˆ›å»º
            User user = mapper.findById(1L);
            System.out.println("æŸ¥è¯¢ç»“æœ: " + user);
        }
    }
    
    @Test
    public void testSimpleStatementHandler() {
        try (SqlSession session = sessionFactory.openSession()) {
            // é€šè¿‡ç›´æ¥SQLæ‰§è¡Œæµ‹è¯•SimpleStatementHandler
            List<User> users = session.selectList("findAllUsers");
            System.out.println("æŸ¥è¯¢ç»“æœ: " + users);
        }
    }
}
```

3. **å…³é”®æ–­ç‚¹è®¾ç½®**
åœ¨ä»¥ä¸‹ä½ç½®è®¾ç½®æ–­ç‚¹ï¼š
- `Configuration.newStatementHandler()`
- `RoutingStatementHandler`æ„é€ æ–¹æ³•
- `PreparedStatementHandler.prepare()`
- `PreparedStatementHandler.parameterize()`
- `PreparedStatementHandler.query()`

4. **è§‚å¯Ÿè¦ç‚¹**
- StatementHandlerçš„åˆ›å»ºè¿‡ç¨‹
- è·¯ç”±é€‰æ‹©é€»è¾‘
- Statementçš„å‡†å¤‡è¿‡ç¨‹
- å‚æ•°è®¾ç½®è¿‡ç¨‹
- SQLæ‰§è¡Œè¿‡ç¨‹

#### éªŒæ”¶æ ‡å‡†
- [ ] èƒ½å¤Ÿå‡†ç¡®æè¿°StatementHandlerçš„åˆ›å»ºæµç¨‹
- [ ] ç†è§£RoutingStatementHandlerçš„è·¯ç”±æœºåˆ¶
- [ ] æŒæ¡PreparedStatementHandlerçš„æ‰§è¡Œæ­¥éª¤
- [ ] èƒ½å¤Ÿè¯†åˆ«ä¸åŒStatementHandlerçš„è¡Œä¸ºå·®å¼‚

---

### ä»»åŠ¡2ï¼šè‡ªå®šä¹‰StatementHandlerå®ç°ï¼ˆè¿›é˜¶ï¼‰
**éš¾åº¦**: â­â­â­â­  
**é¢„è®¡ç”¨æ—¶**: 2å°æ—¶  
**å­¦ä¹ ç›®æ ‡**: æŒæ¡StatementHandlerçš„æ‰©å±•å¼€å‘

#### ä»»åŠ¡æè¿°
å®ç°ä¸€ä¸ªè‡ªå®šä¹‰çš„StatementHandlerï¼Œå…·å¤‡SQLæ‰§è¡Œæ—¶é—´ç›‘æ§å’Œæ…¢æŸ¥è¯¢å‘Šè­¦åŠŸèƒ½ã€‚

#### å®è·µæ­¥éª¤

1. **åˆ›å»ºæ€§èƒ½ç›‘æ§StatementHandler**
```java
/**
 * æ€§èƒ½ç›‘æ§StatementHandler
 * æ”¯æŒSQLæ‰§è¡Œæ—¶é—´ç»Ÿè®¡å’Œæ…¢æŸ¥è¯¢å‘Šè­¦
 */
public class PerformanceMonitorStatementHandler implements StatementHandler {
    
    private final StatementHandler delegate;
    private final long slowQueryThreshold;
    private final PerformanceCollector performanceCollector;
    
    public PerformanceMonitorStatementHandler(StatementHandler delegate, 
                                              long slowQueryThreshold) {
        this.delegate = delegate;
        this.slowQueryThreshold = slowQueryThreshold;
        this.performanceCollector = PerformanceCollector.getInstance();
    }
    
    @Override
    public Statement prepare(Connection connection, Integer transactionTimeout) throws SQLException {
        long startTime = System.currentTimeMillis();
        
        try {
            Statement statement = delegate.prepare(connection, transactionTimeout);
            
            long prepareTime = System.currentTimeMillis() - startTime;
            performanceCollector.recordPrepareTime(getBoundSql().getSql(), prepareTime);
            
            return new PerformanceMonitorStatement(statement, this);
        } catch (SQLException e) {
            performanceCollector.recordPrepareError(getBoundSql().getSql(), e);
            throw e;
        }
    }
    
    @Override
    public void parameterize(Statement statement) throws SQLException {
        long startTime = System.currentTimeMillis();
        
        try {
            // è§£åŒ…è£…å®é™…çš„Statement
            Statement actualStatement = unwrapStatement(statement);
            delegate.parameterize(actualStatement);
            
            long parameterizeTime = System.currentTimeMillis() - startTime;
            performanceCollector.recordParameterizeTime(getBoundSql().getSql(), parameterizeTime);
            
        } catch (SQLException e) {
            performanceCollector.recordParameterizeError(getBoundSql().getSql(), e);
            throw e;
        }
    }
    
    @Override
    public <E> List<E> query(Statement statement, ResultHandler resultHandler) throws SQLException {
        long startTime = System.currentTimeMillis();
        String sql = getBoundSql().getSql();
        
        try {
            Statement actualStatement = unwrapStatement(statement);
            List<E> result = delegate.query(actualStatement, resultHandler);
            
            long executionTime = System.currentTimeMillis() - startTime;
            
            // è®°å½•æ‰§è¡Œç»Ÿè®¡
            performanceCollector.recordQueryExecution(sql, executionTime, result.size());
            
            // æ…¢æŸ¥è¯¢å‘Šè­¦
            if (executionTime > slowQueryThreshold) {
                performanceCollector.recordSlowQuery(sql, executionTime, getBoundSql().getParameterObject());
            }
            
            return result;
            
        } catch (SQLException e) {
            long executionTime = System.currentTimeMillis() - startTime;
            performanceCollector.recordQueryError(sql, executionTime, e);
            throw e;
        }
    }
    
    @Override
    public int update(Statement statement) throws SQLException {
        long startTime = System.currentTimeMillis();
        String sql = getBoundSql().getSql();
        
        try {
            Statement actualStatement = unwrapStatement(statement);
            int result = delegate.update(actualStatement);
            
            long executionTime = System.currentTimeMillis() - startTime;
            performanceCollector.recordUpdateExecution(sql, executionTime, result);
            
            // æ…¢æ›´æ–°å‘Šè­¦
            if (executionTime > slowQueryThreshold) {
                performanceCollector.recordSlowUpdate(sql, executionTime, getBoundSql().getParameterObject());
            }
            
            return result;
            
        } catch (SQLException e) {
            long executionTime = System.currentTimeMillis() - startTime;
            performanceCollector.recordUpdateError(sql, executionTime, e);
            throw e;
        }
    }
    
    // ... å…¶ä»–å§”æ‰˜æ–¹æ³•å®ç°
    
    private Statement unwrapStatement(Statement statement) {
        if (statement instanceof PerformanceMonitorStatement) {
            return ((PerformanceMonitorStatement) statement).getDelegate();
        }
        return statement;
    }
}
```

2. **åˆ›å»ºæ€§èƒ½æ•°æ®æ”¶é›†å™¨**
```java
/**
 * æ€§èƒ½æ•°æ®æ”¶é›†å™¨
 * å•ä¾‹æ¨¡å¼ï¼Œæ”¶é›†å’Œç®¡ç†æ€§èƒ½ç»Ÿè®¡æ•°æ®
 */
public class PerformanceCollector {
    
    private static final PerformanceCollector INSTANCE = new PerformanceCollector();
    private final Map<String, SqlPerformanceStats> performanceStats = new ConcurrentHashMap<>();
    private final List<SlowQueryRecord> slowQueries = new CopyOnWriteArrayList<>();
    
    private PerformanceCollector() {}
    
    public static PerformanceCollector getInstance() {
        return INSTANCE;
    }
    
    public void recordQueryExecution(String sql, long executionTime, int resultCount) {
        SqlPerformanceStats stats = getOrCreateStats(sql);
        stats.recordQueryExecution(executionTime, resultCount);
    }
    
    public void recordUpdateExecution(String sql, long executionTime, int affectedRows) {
        SqlPerformanceStats stats = getOrCreateStats(sql);
        stats.recordUpdateExecution(executionTime, affectedRows);
    }
    
    public void recordSlowQuery(String sql, long executionTime, Object parameters) {
        SlowQueryRecord record = new SlowQueryRecord(sql, executionTime, parameters, new Date());
        slowQueries.add(record);
        
        // å‘Šè­¦é€šçŸ¥
        notifySlowQuery(record);
    }
    
    public void recordSlowUpdate(String sql, long executionTime, Object parameters) {
        SlowQueryRecord record = new SlowQueryRecord(sql, executionTime, parameters, new Date(), "UPDATE");
        slowQueries.add(record);
        
        // å‘Šè­¦é€šçŸ¥
        notifySlowQuery(record);
    }
    
    public SqlPerformanceStats getPerformanceStats(String sql) {
        return performanceStats.get(sql);
    }
    
    public List<SlowQueryRecord> getSlowQueries() {
        return new ArrayList<>(slowQueries);
    }
    
    public Map<String, SqlPerformanceStats> getAllPerformanceStats() {
        return new HashMap<>(performanceStats);
    }
    
    private SqlPerformanceStats getOrCreateStats(String sql) {
        return performanceStats.computeIfAbsent(sql, k -> new SqlPerformanceStats(sql));
    }
    
    private void notifySlowQuery(SlowQueryRecord record) {
        // å®ç°å‘Šè­¦é€»è¾‘ï¼šæ—¥å¿—è®°å½•ã€é‚®ä»¶é€šçŸ¥ã€ç›‘æ§ç³»ç»Ÿç­‰
        System.err.println("æ…¢æŸ¥è¯¢å‘Šè­¦: " + record);
    }
}
```

3. **åˆ›å»ºæ’ä»¶é›†æˆ**
```java
/**
 * StatementHandleræ€§èƒ½ç›‘æ§æ’ä»¶
 */
@Intercepts({
    @Signature(type = StatementHandler.class, method = "prepare", args = {Connection.class, Integer.class})
})
public class PerformanceMonitorPlugin implements Interceptor {
    
    private long slowQueryThreshold = 1000; // é»˜è®¤1ç§’
    
    @Override
    public Object intercept(Invocation invocation) throws Throwable {
        StatementHandler statementHandler = (StatementHandler) invocation.getTarget();
        
        // åŒ…è£…ä¸ºæ€§èƒ½ç›‘æ§StatementHandler
        PerformanceMonitorStatementHandler monitorHandler = 
            new PerformanceMonitorStatementHandler(statementHandler, slowQueryThreshold);
        
        // æ›¿æ¢target
        return monitorHandler.prepare((Connection) invocation.getArgs()[0], 
                                      (Integer) invocation.getArgs()[1]);
    }
    
    @Override
    public Object plugin(Object target) {
        return Plugin.wrap(target, this);
    }
    
    @Override
    public void setProperties(Properties properties) {
        String threshold = properties.getProperty("slowQueryThreshold");
        if (threshold != null) {
            this.slowQueryThreshold = Long.parseLong(threshold);
        }
    }
}
```

4. **æ€§èƒ½æŠ¥å‘Šç”Ÿæˆ**
```java
/**
 * æ€§èƒ½æŠ¥å‘Šç”Ÿæˆå™¨
 */
public class PerformanceReportGenerator {
    
    private final PerformanceCollector collector;
    
    public PerformanceReportGenerator() {
        this.collector = PerformanceCollector.getInstance();
    }
    
    public String generateReport() {
        StringBuilder report = new StringBuilder();
        
        report.append("=== MyBatis Performance Report ===\n\n");
        
        // æ€»ä½“ç»Ÿè®¡
        generateOverviewReport(report);
        
        // æ…¢æŸ¥è¯¢æŠ¥å‘Š
        generateSlowQueryReport(report);
        
        // è¯¦ç»†SQLç»Ÿè®¡
        generateDetailedStatsReport(report);
        
        return report.toString();
    }
    
    private void generateOverviewReport(StringBuilder report) {
        Map<String, SqlPerformanceStats> allStats = collector.getAllPerformanceStats();
        
        int totalSqlCount = allStats.size();
        long totalExecutions = allStats.values().stream()
            .mapToLong(SqlPerformanceStats::getTotalExecutions)
            .sum();
        double avgExecutionTime = allStats.values().stream()
            .mapToDouble(SqlPerformanceStats::getAverageExecutionTime)
            .average()
            .orElse(0.0);
        
        report.append("æ€»ä½“ç»Ÿè®¡:\n");
        report.append(String.format("  SQLè¯­å¥æ€»æ•°: %d\n", totalSqlCount));
        report.append(String.format("  æ€»æ‰§è¡Œæ¬¡æ•°: %d\n", totalExecutions));
        report.append(String.format("  å¹³å‡æ‰§è¡Œæ—¶é—´: %.2f ms\n", avgExecutionTime));
        report.append(String.format("  æ…¢æŸ¥è¯¢æ•°é‡: %d\n", collector.getSlowQueries().size()));
        report.append("\n");
    }
    
    private void generateSlowQueryReport(StringBuilder report) {
        List<SlowQueryRecord> slowQueries = collector.getSlowQueries();
        
        report.append("æ…¢æŸ¥è¯¢æŠ¥å‘Š:\n");
        if (slowQueries.isEmpty()) {
            report.append("  æ— æ…¢æŸ¥è¯¢è®°å½•\n");
        } else {
            slowQueries.stream()
                .sorted((a, b) -> Long.compare(b.getExecutionTime(), a.getExecutionTime()))
                .limit(10)
                .forEach(record -> {
                    report.append(String.format("  [%s] %d ms - %s\n", 
                        record.getOperationType(), 
                        record.getExecutionTime(), 
                        truncateSQL(record.getSql(), 100)));
                });
        }
        report.append("\n");
    }
    
    private void generateDetailedStatsReport(StringBuilder report) {
        Map<String, SqlPerformanceStats> allStats = collector.getAllPerformanceStats();
        
        report.append("è¯¦ç»†SQLç»Ÿè®¡ (Top 10):\n");
        allStats.values().stream()
            .sorted((a, b) -> Long.compare(b.getTotalExecutions(), a.getTotalExecutions()))
            .limit(10)
            .forEach(stats -> {
                report.append(String.format("  SQL: %s\n", truncateSQL(stats.getSql(), 80)));
                report.append(String.format("    æ‰§è¡Œæ¬¡æ•°: %d, å¹³å‡æ—¶é—´: %.2f ms, æœ€å¤§æ—¶é—´: %d ms\n",
                    stats.getTotalExecutions(),
                    stats.getAverageExecutionTime(),
                    stats.getMaxExecutionTime()));
                report.append("\n");
            });
    }
    
    private String truncateSQL(String sql, int maxLength) {
        if (sql.length() <= maxLength) {
            return sql;
        }
        return sql.substring(0, maxLength) + "...";
    }
}
```

#### éªŒæ”¶æ ‡å‡†
- [ ] æˆåŠŸå®ç°æ€§èƒ½ç›‘æ§StatementHandler
- [ ] èƒ½å¤Ÿæ”¶é›†SQLæ‰§è¡Œç»Ÿè®¡æ•°æ®
- [ ] å®ç°æ…¢æŸ¥è¯¢å‘Šè­¦æœºåˆ¶
- [ ] èƒ½å¤Ÿç”Ÿæˆæ€§èƒ½æŠ¥å‘Š
- [ ] é€šè¿‡æ’ä»¶æ–¹å¼é›†æˆåˆ°MyBatisä¸­

---

### ä»»åŠ¡3ï¼šStatementHandleræ‹¦æˆªå™¨å¼€å‘ï¼ˆé«˜çº§ï¼‰
**éš¾åº¦**: â­â­â­â­â­  
**é¢„è®¡ç”¨æ—¶**: 3å°æ—¶  
**å­¦ä¹ ç›®æ ‡**: æ·±å…¥ç†è§£StatementHandlerçš„æ‹¦æˆªæœºåˆ¶

#### ä»»åŠ¡æè¿°
å¼€å‘ä¸€ä¸ªåŠŸèƒ½å®Œæ•´çš„StatementHandleræ‹¦æˆªå™¨ï¼Œæ”¯æŒSQLæ”¹å†™ã€å‚æ•°åŠ å¯†ã€ç»“æœè„±æ•ç­‰åŠŸèƒ½ã€‚

#### å®è·µæ­¥éª¤

1. **å¤šåŠŸèƒ½æ‹¦æˆªå™¨è®¾è®¡**
```java
/**
 * å¤šåŠŸèƒ½StatementHandleræ‹¦æˆªå™¨
 * æ”¯æŒSQLæ”¹å†™ã€å‚æ•°åŠ å¯†ã€ç»“æœè„±æ•ç­‰åŠŸèƒ½
 */
@Intercepts({
    @Signature(type = StatementHandler.class, method = "prepare", args = {Connection.class, Integer.class}),
    @Signature(type = StatementHandler.class, method = "parameterize", args = {Statement.class}),
    @Signature(type = StatementHandler.class, method = "query", args = {Statement.class, ResultHandler.class})
})
public class AdvancedStatementInterceptor implements Interceptor {
    
    private final SqlRewriter sqlRewriter;
    private final ParameterEncryptor parameterEncryptor;
    private final ResultDesensitizer resultDesensitizer;
    private final InterceptorConfig config;
    
    public AdvancedStatementInterceptor() {
        this.sqlRewriter = new SqlRewriter();
        this.parameterEncryptor = new ParameterEncryptor();
        this.resultDesensitizer = new ResultDesensitizer();
        this.config = new InterceptorConfig();
    }
    
    @Override
    public Object intercept(Invocation invocation) throws Throwable {
        StatementHandler statementHandler = (StatementHandler) invocation.getTarget();
        String methodName = invocation.getMethod().getName();
        
        switch (methodName) {
            case "prepare":
                return handlePrepare(invocation, statementHandler);
            case "parameterize":
                return handleParameterize(invocation, statementHandler);
            case "query":
                return handleQuery(invocation, statementHandler);
            default:
                return invocation.proceed();
        }
    }
    
    private Object handlePrepare(Invocation invocation, StatementHandler statementHandler) throws Throwable {
        // SQLæ”¹å†™å¤„ç†
        if (config.isSqlRewriteEnabled()) {
            rewriteSQL(statementHandler);
        }
        
        // ç»§ç»­æ‰§è¡ŒåŸå§‹prepareé€»è¾‘
        return invocation.proceed();
    }
    
    private Object handleParameterize(Invocation invocation, StatementHandler statementHandler) throws Throwable {
        // å‚æ•°åŠ å¯†å¤„ç†
        if (config.isParameterEncryptionEnabled()) {
            encryptParameters(statementHandler);
        }
        
        // ç»§ç»­æ‰§è¡ŒåŸå§‹parameterizeé€»è¾‘
        return invocation.proceed();
    }
    
    private Object handleQuery(Invocation invocation, StatementHandler statementHandler) throws Throwable {
        // æ‰§è¡ŒåŸå§‹æŸ¥è¯¢
        Object result = invocation.proceed();
        
        // ç»“æœè„±æ•å¤„ç†
        if (config.isResultDesensitizationEnabled() && result instanceof List) {
            return desensitizeResults((List<?>) result, statementHandler);
        }
        
        return result;
    }
    
    private void rewriteSQL(StatementHandler statementHandler) {
        BoundSql boundSql = statementHandler.getBoundSql();
        String originalSql = boundSql.getSql();
        
        // æ·»åŠ ç§Ÿæˆ·éš”ç¦»æ¡ä»¶
        if (config.isTenantIsolationEnabled()) {
            String rewrittenSql = sqlRewriter.addTenantCondition(originalSql, getCurrentTenantId());
            modifyBoundSql(boundSql, rewrittenSql);
        }
        
        // æ·»åŠ æ•°æ®æƒé™è¿‡æ»¤
        if (config.isDataPermissionEnabled()) {
            String rewrittenSql = sqlRewriter.addDataPermissionFilter(originalSql, getCurrentUserPermissions());
            modifyBoundSql(boundSql, rewrittenSql);
        }
        
        // æ·»åŠ åˆ†åº“åˆ†è¡¨è·¯ç”±
        if (config.isShardingEnabled()) {
            String rewrittenSql = sqlRewriter.addShardingRoute(originalSql, boundSql.getParameterObject());
            modifyBoundSql(boundSql, rewrittenSql);
        }
    }
    
    private void encryptParameters(StatementHandler statementHandler) {
        BoundSql boundSql = statementHandler.getBoundSql();
        Object parameterObject = boundSql.getParameterObject();
        
        if (parameterObject != null) {
            // åŠ å¯†æ•æ„Ÿå‚æ•°
            Object encryptedParameters = parameterEncryptor.encrypt(parameterObject);
            modifyParameterObject(boundSql, encryptedParameters);
        }
    }
    
    private List<?> desensitizeResults(List<?> results, StatementHandler statementHandler) {
        if (results.isEmpty()) {
            return results;
        }
        
        // è·å–æ˜ å°„è¯­å¥ä¿¡æ¯ï¼Œåˆ¤æ–­æ˜¯å¦éœ€è¦è„±æ•
        String statementId = getStatementId(statementHandler);
        if (config.requiresDesensitization(statementId)) {
            return resultDesensitizer.desensitize(results);
        }
        
        return results;
    }
    
    // ... è¾…åŠ©æ–¹æ³•å®ç°
}
```

2. **SQLæ”¹å†™å™¨å®ç°**
```java
/**
 * SQLæ”¹å†™å™¨
 * æ”¯æŒå¤šç§SQLæ”¹å†™åœºæ™¯
 */
public class SqlRewriter {
    
    private final SqlParser sqlParser;
    
    public SqlRewriter() {
        this.sqlParser = new SqlParser();
    }
    
    public String addTenantCondition(String originalSql, String tenantId) {
        ParsedSql parsedSql = sqlParser.parse(originalSql);
        
        if (parsedSql.isSelectStatement()) {
            return addTenantConditionToSelect(parsedSql, tenantId);
        } else if (parsedSql.isUpdateStatement()) {
            return addTenantConditionToUpdate(parsedSql, tenantId);
        } else if (parsedSql.isDeleteStatement()) {
            return addTenantConditionToDelete(parsedSql, tenantId);
        }
        
        return originalSql;
    }
    
    public String addDataPermissionFilter(String originalSql, Set<String> userPermissions) {
        ParsedSql parsedSql = sqlParser.parse(originalSql);
        
        // æ ¹æ®ç”¨æˆ·æƒé™æ·»åŠ æ•°æ®è¿‡æ»¤æ¡ä»¶
        if (parsedSql.containsTable("user") && !userPermissions.contains("VIEW_ALL_USERS")) {
            return addUserDataFilter(parsedSql);
        }
        
        if (parsedSql.containsTable("order") && !userPermissions.contains("VIEW_ALL_ORDERS")) {
            return addOrderDataFilter(parsedSql);
        }
        
        return originalSql;
    }
    
    public String addShardingRoute(String originalSql, Object parameterObject) {
        ParsedSql parsedSql = sqlParser.parse(originalSql);
        
        // æ ¹æ®åˆ†ç‰‡é”®è®¡ç®—ç›®æ ‡è¡¨
        if (parsedSql.containsTable("order")) {
            String shardSuffix = calculateOrderShardSuffix(parameterObject);
            return parsedSql.replaceTableName("order", "order_" + shardSuffix);
        }
        
        if (parsedSql.containsTable("user")) {
            String shardSuffix = calculateUserShardSuffix(parameterObject);
            return parsedSql.replaceTableName("user", "user_" + shardSuffix);
        }
        
        return originalSql;
    }
    
    private String addTenantConditionToSelect(ParsedSql parsedSql, String tenantId) {
        // åœ¨WHEREå­å¥ä¸­æ·»åŠ ç§Ÿæˆ·æ¡ä»¶
        if (parsedSql.hasWhereClause()) {
            return parsedSql.addWhereCondition("tenant_id = '" + tenantId + "'");
        } else {
            return parsedSql.addWhereClause("WHERE tenant_id = '" + tenantId + "'");
        }
    }
    
    private String calculateOrderShardSuffix(Object parameterObject) {
        // æ ¹æ®è®¢å•IDæˆ–ç”¨æˆ·IDè®¡ç®—åˆ†ç‰‡åç¼€
        if (parameterObject instanceof Map) {
            Map<String, Object> params = (Map<String, Object>) parameterObject;
            Object orderId = params.get("orderId");
            if (orderId != null) {
                return String.valueOf(Math.abs(orderId.hashCode()) % 4);
            }
        }
        return "0";
    }
    
    // ... å…¶ä»–è¾…åŠ©æ–¹æ³•
}
```

3. **å‚æ•°åŠ å¯†å™¨å®ç°**
```java
/**
 * å‚æ•°åŠ å¯†å™¨
 * å¯¹æ•æ„Ÿå‚æ•°è¿›è¡ŒåŠ å¯†å¤„ç†
 */
public class ParameterEncryptor {
    
    private final AESEncryptor aesEncryptor;
    private final Set<String> sensitiveFields;
    
    public ParameterEncryptor() {
        this.aesEncryptor = new AESEncryptor();
        this.sensitiveFields = initSensitiveFields();
    }
    
    public Object encrypt(Object parameterObject) {
        if (parameterObject == null) {
            return null;
        }
        
        if (parameterObject instanceof Map) {
            return encryptMapParameters((Map<String, Object>) parameterObject);
        } else {
            return encryptObjectParameters(parameterObject);
        }
    }
    
    private Map<String, Object> encryptMapParameters(Map<String, Object> parameters) {
        Map<String, Object> encryptedParams = new HashMap<>(parameters);
        
        for (Map.Entry<String, Object> entry : parameters.entrySet()) {
            String fieldName = entry.getKey();
            Object value = entry.getValue();
            
            if (isSensitiveField(fieldName) && value instanceof String) {
                String encryptedValue = aesEncryptor.encrypt((String) value);
                encryptedParams.put(fieldName, encryptedValue);
            }
        }
        
        return encryptedParams;
    }
    
    private Object encryptObjectParameters(Object parameterObject) {
        Class<?> clazz = parameterObject.getClass();
        
        // ä½¿ç”¨åå°„è·å–æ‰€æœ‰å­—æ®µ
        Field[] fields = clazz.getDeclaredFields();
        
        try {
            Object encryptedObject = clazz.newInstance();
            
            for (Field field : fields) {
                field.setAccessible(true);
                Object value = field.get(parameterObject);
                
                if (isSensitiveField(field.getName()) && value instanceof String) {
                    String encryptedValue = aesEncryptor.encrypt((String) value);
                    field.set(encryptedObject, encryptedValue);
                } else {
                    field.set(encryptedObject, value);
                }
            }
            
            return encryptedObject;
            
        } catch (Exception e) {
            throw new RuntimeException("Failed to encrypt parameters", e);
        }
    }
    
    private boolean isSensitiveField(String fieldName) {
        return sensitiveFields.contains(fieldName.toLowerCase()) ||
               fieldName.toLowerCase().contains("password") ||
               fieldName.toLowerCase().contains("secret") ||
               fieldName.toLowerCase().contains("token");
    }
    
    private Set<String> initSensitiveFields() {
        Set<String> fields = new HashSet<>();
        fields.add("password");
        fields.add("secret");
        fields.add("token");
        fields.add("phone");
        fields.add("idcard");
        fields.add("bankaccount");
        return fields;
    }
}
```

4. **ç»“æœè„±æ•å™¨å®ç°**
```java
/**
 * ç»“æœè„±æ•å™¨
 * å¯¹æŸ¥è¯¢ç»“æœä¸­çš„æ•æ„Ÿæ•°æ®è¿›è¡Œè„±æ•å¤„ç†
 */
public class ResultDesensitizer {
    
    private final Map<String, DesensitizeStrategy> strategies;
    
    public ResultDesensitizer() {
        this.strategies = initDesensitizeStrategies();
    }
    
    public List<?> desensitize(List<?> results) {
        if (results.isEmpty()) {
            return results;
        }
        
        return results.stream()
            .map(this::desensitizeObject)
            .collect(Collectors.toList());
    }
    
    private Object desensitizeObject(Object obj) {
        if (obj == null) {
            return null;
        }
        
        if (obj instanceof Map) {
            return desensitizeMap((Map<String, Object>) obj);
        } else {
            return desensitizePojo(obj);
        }
    }
    
    private Map<String, Object> desensitizeMap(Map<String, Object> map) {
        Map<String, Object> desensitizedMap = new HashMap<>(map);
        
        for (Map.Entry<String, Object> entry : map.entrySet()) {
            String fieldName = entry.getKey();
            Object value = entry.getValue();
            
            if (value instanceof String) {
                DesensitizeStrategy strategy = getStrategy(fieldName);
                if (strategy != null) {
                    String desensitizedValue = strategy.desensitize((String) value);
                    desensitizedMap.put(fieldName, desensitizedValue);
                }
            }
        }
        
        return desensitizedMap;
    }
    
    private Object desensitizePojo(Object obj) {
        Class<?> clazz = obj.getClass();
        Field[] fields = clazz.getDeclaredFields();
        
        try {
            Object desensitizedObject = clazz.newInstance();
            
            for (Field field : fields) {
                field.setAccessible(true);
                Object value = field.get(obj);
                
                if (value instanceof String) {
                    DesensitizeStrategy strategy = getStrategy(field.getName());
                    if (strategy != null) {
                        String desensitizedValue = strategy.desensitize((String) value);
                        field.set(desensitizedObject, desensitizedValue);
                    } else {
                        field.set(desensitizedObject, value);
                    }
                } else {
                    field.set(desensitizedObject, value);
                }
            }
            
            return desensitizedObject;
            
        } catch (Exception e) {
            throw new RuntimeException("Failed to desensitize object", e);
        }
    }
    
    private DesensitizeStrategy getStrategy(String fieldName) {
        return strategies.get(fieldName.toLowerCase());
    }
    
    private Map<String, DesensitizeStrategy> initDesensitizeStrategies() {
        Map<String, DesensitizeStrategy> strategies = new HashMap<>();
        
        // æ‰‹æœºå·è„±æ•ï¼š138****1234
        strategies.put("phone", value -> {
            if (value.length() == 11) {
                return value.substring(0, 3) + "****" + value.substring(7);
            }
            return value;
        });
        
        // èº«ä»½è¯è„±æ•ï¼š110101**********01
        strategies.put("idcard", value -> {
            if (value.length() == 18) {
                return value.substring(0, 6) + "**********" + value.substring(16);
            }
            return value;
        });
        
        // é“¶è¡Œå¡è„±æ•ï¼š6222****1234
        strategies.put("bankaccount", value -> {
            if (value.length() >= 8) {
                return value.substring(0, 4) + "****" + value.substring(value.length() - 4);
            }
            return value;
        });
        
        // é‚®ç®±è„±æ•ï¼štest***@example.com
        strategies.put("email", value -> {
            int atIndex = value.indexOf("@");
            if (atIndex > 0) {
                String name = value.substring(0, atIndex);
                String domain = value.substring(atIndex);
                if (name.length() > 3) {
                    return name.substring(0, 3) + "***" + domain;
                }
            }
            return value;
        });
        
        return strategies;
    }
    
    @FunctionalInterface
    private interface DesensitizeStrategy {
        String desensitize(String value);
    }
}
```

#### éªŒæ”¶æ ‡å‡†
- [ ] æˆåŠŸå®ç°å¤šåŠŸèƒ½æ‹¦æˆªå™¨
- [ ] SQLæ”¹å†™åŠŸèƒ½æ­£å¸¸å·¥ä½œ
- [ ] å‚æ•°åŠ å¯†åŠŸèƒ½æ­£å¸¸å·¥ä½œ
- [ ] ç»“æœè„±æ•åŠŸèƒ½æ­£å¸¸å·¥ä½œ
- [ ] æ‹¦æˆªå™¨é…ç½®çµæ´»å¯æ§
- [ ] æ€§èƒ½å½±å“åœ¨å¯æ¥å—èŒƒå›´å†…

---

### ä»»åŠ¡4ï¼šStatementHandleræ€§èƒ½å¯¹æ¯”åˆ†æï¼ˆåˆ†æï¼‰
**éš¾åº¦**: â­â­â­  
**é¢„è®¡ç”¨æ—¶**: 1å°æ—¶  
**å­¦ä¹ ç›®æ ‡**: æ·±å…¥ç†è§£ä¸åŒStatementHandlerçš„æ€§èƒ½ç‰¹å¾

#### ä»»åŠ¡æè¿°
é€šè¿‡åŸºå‡†æµ‹è¯•å¯¹æ¯”åˆ†æä¸åŒStatementHandlerçš„æ€§èƒ½è¡¨ç°ï¼Œç†è§£å…¶é€‚ç”¨åœºæ™¯ã€‚

#### å®è·µæ­¥éª¤

1. **åˆ›å»ºæ€§èƒ½æµ‹è¯•æ¡†æ¶**
```java
/**
 * StatementHandleræ€§èƒ½æµ‹è¯•
 */
public class StatementHandlerPerformanceTest {
    
    private SqlSessionFactory sessionFactory;
    private final int ITERATION_COUNT = 1000;
    private final int WARMUP_COUNT = 100;
    
    @Before
    public void setup() throws IOException {
        String resource = "mybatis-config.xml";
        InputStream inputStream = Resources.getResourceAsStream(resource);
        sessionFactory = new SqlSessionFactoryBuilder().build(inputStream);
        
        // é¢„çƒ­
        warmup();
    }
    
    private void warmup() {
        for (int i = 0; i < WARMUP_COUNT; i++) {
            try (SqlSession session = sessionFactory.openSession()) {
                UserMapper mapper = session.getMapper(UserMapper.class);
                mapper.findById(1L);
            }
        }
    }
    
    @Test
    public void testPreparedStatementPerformance() {
        // é…ç½®ä½¿ç”¨PreparedStatement
        long executionTime = measureExecutionTime(() -> {
            try (SqlSession session = sessionFactory.openSession()) {
                UserMapper mapper = session.getMapper(UserMapper.class);
                for (int i = 0; i < ITERATION_COUNT; i++) {
                    mapper.findById((long) (i % 100 + 1));
                }
            }
        });
        
        System.out.println("PreparedStatementå¹³å‡æ‰§è¡Œæ—¶é—´: " + 
                          (executionTime / ITERATION_COUNT) + " ns");
    }
    
    @Test
    public void testSimpleStatementPerformance() {
        // é…ç½®ä½¿ç”¨SimpleStatement
        long executionTime = measureExecutionTime(() -> {
            try (SqlSession session = sessionFactory.openSession()) {
                for (int i = 0; i < ITERATION_COUNT; i++) {
                    session.selectOne("findUserByIdSimple", (long) (i % 100 + 1));
                }
            }
        });
        
        System.out.println("SimpleStatementå¹³å‡æ‰§è¡Œæ—¶é—´: " + 
                          (executionTime / ITERATION_COUNT) + " ns");
    }
    
    @Test
    public void testBatchUpdatePerformance() {
        long executionTime = measureExecutionTime(() -> {
            try (SqlSession session = sessionFactory.openSession(ExecutorType.BATCH)) {
                UserMapper mapper = session.getMapper(UserMapper.class);
                for (int i = 0; i < ITERATION_COUNT; i++) {
                    User user = new User();
                    user.setName("Test" + i);
                    user.setAge(20 + i % 50);
                    mapper.insert(user);
                }
                session.flushStatements();
                session.commit();
            }
        });
        
        System.out.println("BatchStatementæ‰¹é‡æ’å…¥æ—¶é—´: " + executionTime + " ms");
    }
    
    @Test
    public void testMemoryUsage() {
        // å†…å­˜ä½¿ç”¨æƒ…å†µæµ‹è¯•
        Runtime runtime = Runtime.getRuntime();
        
        long beforeMemory = runtime.totalMemory() - runtime.freeMemory();
        
        // æ‰§è¡Œå¤§é‡æŸ¥è¯¢
        try (SqlSession session = sessionFactory.openSession()) {
            UserMapper mapper = session.getMapper(UserMapper.class);
            for (int i = 0; i < ITERATION_COUNT * 10; i++) {
                mapper.findById((long) (i % 100 + 1));
            }
        }
        
        System.gc();
        Thread.sleep(1000); // ç­‰å¾…GC
        
        long afterMemory = runtime.totalMemory() - runtime.freeMemory();
        long memoryUsed = afterMemory - beforeMemory;
        
        System.out.println("å†…å­˜ä½¿ç”¨é‡: " + (memoryUsed / 1024 / 1024) + " MB");
    }
    
    private long measureExecutionTime(Runnable task) {
        long startTime = System.nanoTime();
        task.run();
        long endTime = System.nanoTime();
        return endTime - startTime;
    }
}
```

2. **åˆ›å»ºæ€§èƒ½åˆ†ææŠ¥å‘Š**
```java
/**
 * æ€§èƒ½åˆ†ææŠ¥å‘Šç”Ÿæˆå™¨
 */
public class PerformanceAnalysisReport {
    
    public void generateReport() {
        System.out.println("=== StatementHandleræ€§èƒ½åˆ†ææŠ¥å‘Š ===\n");
        
        // æµ‹è¯•ä¸åŒåœºæ™¯ä¸‹çš„æ€§èƒ½
        testSingleQueryPerformance();
        testBatchOperationPerformance();
        testMemoryEfficiency();
        testConnectionUtilization();
    }
    
    private void testSingleQueryPerformance() {
        System.out.println("1. å•æŸ¥è¯¢æ€§èƒ½å¯¹æ¯”:");
        
        // PreparedStatement vs SimpleStatement
        long preparedTime = benchmarkPreparedStatement();
        long simpleTime = benchmarkSimpleStatement();
        
        System.out.println("  PreparedStatement: " + preparedTime + " ms");
        System.out.println("  SimpleStatement: " + simpleTime + " ms");
        System.out.println("  æ€§èƒ½æå‡: " + 
                          String.format("%.2f%%", ((double)(simpleTime - preparedTime) / simpleTime) * 100));
        System.out.println();
    }
    
    private void testBatchOperationPerformance() {
        System.out.println("2. æ‰¹é‡æ“ä½œæ€§èƒ½å¯¹æ¯”:");
        
        long batchTime = benchmarkBatchOperation();
        long individualTime = benchmarkIndividualOperation();
        
        System.out.println("  æ‰¹é‡æ“ä½œ: " + batchTime + " ms");
        System.out.println("  å•æ¡æ“ä½œ: " + individualTime + " ms");
        System.out.println("  æ€§èƒ½æå‡: " + 
                          String.format("%.2fx", (double)individualTime / batchTime));
        System.out.println();
    }
    
    private void testMemoryEfficiency() {
        System.out.println("3. å†…å­˜æ•ˆç‡åˆ†æ:");
        
        MemoryMXBean memoryBean = ManagementFactory.getMemoryMXBean();
        
        long beforeMemory = memoryBean.getHeapMemoryUsage().getUsed();
        
        // æ‰§è¡Œå†…å­˜å¯†é›†å‹æ“ä½œ
        performMemoryIntensiveOperations();
        
        System.gc();
        
        long afterMemory = memoryBean.getHeapMemoryUsage().getUsed();
        long memoryUsed = afterMemory - beforeMemory;
        
        System.out.println("  å†…å­˜ä½¿ç”¨é‡: " + (memoryUsed / 1024 / 1024) + " MB");
        System.out.println("  å¹³å‡æ¯æ¬¡æŸ¥è¯¢å†…å­˜å¼€é”€: " + (memoryUsed / 1000 / 1024) + " KB");
        System.out.println();
    }
    
    private void testConnectionUtilization() {
        System.out.println("4. è¿æ¥åˆ©ç”¨æ•ˆç‡:");
        
        // æµ‹è¯•è¿æ¥æ± åˆ©ç”¨æƒ…å†µ
        long connectionActiveTime = measureConnectionActiveTime();
        long totalTime = measureTotalExecutionTime();
        
        double utilizationRate = (double)connectionActiveTime / totalTime * 100;
        
        System.out.println("  è¿æ¥æ´»è·ƒæ—¶é—´: " + connectionActiveTime + " ms");
        System.out.println("  æ€»æ‰§è¡Œæ—¶é—´: " + totalTime + " ms");
        System.out.println("  è¿æ¥åˆ©ç”¨ç‡: " + String.format("%.2f%%", utilizationRate));
        System.out.println();
    }
    
    // ... å…·ä½“çš„åŸºå‡†æµ‹è¯•æ–¹æ³•å®ç°
}
```

#### éªŒæ”¶æ ‡å‡†
- [ ] å®Œæˆä¸åŒStatementHandlerçš„æ€§èƒ½å¯¹æ¯”
- [ ] åˆ†æå†…å­˜ä½¿ç”¨æ•ˆç‡
- [ ] æµ‹è¯•æ‰¹é‡æ“ä½œæ€§èƒ½å·®å¼‚
- [ ] ç”Ÿæˆè¯¦ç»†çš„æ€§èƒ½åˆ†ææŠ¥å‘Š
- [ ] æå‡ºæ€§èƒ½ä¼˜åŒ–å»ºè®®

---

## ğŸ“Š å®è·µæ€»ç»“

### å­¦ä¹ æ”¶è·è¯„ä¼°
å®Œæˆä¸Šè¿°å®è·µä»»åŠ¡åï¼Œä½ åº”è¯¥èƒ½å¤Ÿï¼š

1. **æ·±å…¥ç†è§£**StatementHandlerçš„å·¥ä½œæœºåˆ¶å’Œç”Ÿå‘½å‘¨æœŸ
2. **ç†Ÿç»ƒæŒæ¡**ä¸åŒStatementHandlerçš„ç‰¹ç‚¹å’Œé€‚ç”¨åœºæ™¯
3. **å…·å¤‡èƒ½åŠ›**å¼€å‘è‡ªå®šä¹‰StatementHandleræ‰©å±•
4. **ç†è§£åŸç†**StatementHandlerçš„æ€§èƒ½ç‰¹å¾å’Œä¼˜åŒ–è¦ç‚¹
5. **å®è·µåº”ç”¨**StatementHandleræ‹¦æˆªå™¨å¼€å‘æŠ€èƒ½

### åç»­å­¦ä¹ å»ºè®®

1. **æ·±å…¥ç ”ç©¶**MyBatisæ’ä»¶æœºåˆ¶çš„é«˜çº§ç”¨æ³•
2. **å­¦ä¹ äº†è§£**æ•°æ®åº“è¿æ¥æ± ä¸StatementHandlerçš„é…åˆ
3. **å®è·µæ¢ç´¢**åˆ†å¸ƒå¼ç¯å¢ƒä¸‹StatementHandlerçš„æ‰©å±•
4. **æ€§èƒ½è°ƒä¼˜**åœ¨ç”Ÿäº§ç¯å¢ƒä¸­åº”ç”¨StatementHandlerä¼˜åŒ–

### å¸¸è§é—®é¢˜è§£ç­”

**Q: ä¸ºä»€ä¹ˆPreparedStatementæ¯”SimpleStatementæ€§èƒ½æ›´å¥½ï¼Ÿ**
A: PreparedStatementé¢„ç¼–è¯‘SQLï¼Œæ•°æ®åº“å¯ä»¥ç¼“å­˜æ‰§è¡Œè®¡åˆ’ï¼Œå‡å°‘é‡å¤è§£æå¼€é”€ã€‚

**Q: ä»€ä¹ˆæ—¶å€™åº”è¯¥ä½¿ç”¨CallableStatementHandlerï¼Ÿ**
A: å½“éœ€è¦è°ƒç”¨å­˜å‚¨è¿‡ç¨‹ï¼Œç‰¹åˆ«æ˜¯æœ‰OUTå‚æ•°çš„å­˜å‚¨è¿‡ç¨‹æ—¶ã€‚

**Q: å¦‚ä½•é€‰æ‹©åˆé€‚çš„StatementHandlerï¼Ÿ**
A: æ ¹æ®å…·ä½“éœ€æ±‚ï¼šä¸€èˆ¬ä¸šåŠ¡ç”¨PreparedStatementï¼Œæ‰¹é‡æ“ä½œè€ƒè™‘BatchExecutorï¼Œå­˜å‚¨è¿‡ç¨‹ç”¨CallableStatementã€‚

**Q: StatementHandleræ‹¦æˆªå™¨ä¼šå½±å“æ€§èƒ½å—ï¼Ÿ**
A: ä¼šæœ‰ä¸€å®šå½±å“ï¼Œä½†åˆç†è®¾è®¡çš„æ‹¦æˆªå™¨å½±å“å¾ˆå°ï¼Œå…³é”®æ˜¯é¿å…é‡å¤åå°„å’Œä¸å¿…è¦çš„æ“ä½œã€‚

é€šè¿‡è¿™äº›å®è·µä»»åŠ¡ï¼Œä½ å°†å…¨é¢æŒæ¡StatementHandlerçš„ä½¿ç”¨å’Œæ‰©å±•å¼€å‘æŠ€èƒ½ï¼