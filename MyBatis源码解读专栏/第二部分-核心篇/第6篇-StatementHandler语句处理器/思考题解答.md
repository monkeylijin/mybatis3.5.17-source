# StatementHandlerè¯­å¥å¤„ç†å™¨æ€è€ƒé¢˜è§£ç­”

## ğŸ“š æ·±åº¦æ€è€ƒé¢˜

### æ€è€ƒé¢˜1ï¼šä¸ºä»€ä¹ˆMyBatisè¦è®¾è®¡å¤šç§StatementHandlerï¼Œè€Œä¸æ˜¯ä½¿ç”¨ç»Ÿä¸€çš„å®ç°ï¼Ÿ

**é—®é¢˜èƒŒæ™¯**ï¼š
MyBatisæä¾›äº†SimpleStatementHandlerã€PreparedStatementHandlerã€CallableStatementHandlerä¸‰ç§ä¸åŒçš„å®ç°ï¼Œè¿™æ ·çš„è®¾è®¡æœ‰ä»€ä¹ˆæ·±å±‚æ¬¡çš„è€ƒè™‘ï¼Ÿ

**æ·±åº¦è§£ç­”**ï¼š

#### 1. JDBC APIçš„å¤šæ ·æ€§éœ€æ±‚
```java
// JDBCæœ¬èº«æä¾›äº†ä¸‰ç§ä¸åŒçš„Statementæ¥å£
Statement stmt = connection.createStatement();           // ç®€å•è¯­å¥
PreparedStatement pstmt = connection.prepareStatement(sql); // é¢„ç¼–è¯‘è¯­å¥  
CallableStatement cstmt = connection.prepareCall(sql);      // å­˜å‚¨è¿‡ç¨‹è°ƒç”¨
```

#### 2. æ€§èƒ½ç‰¹å¾å·®å¼‚å·¨å¤§

| Statementç±»å‹ | ç¼–è¯‘æ–¹å¼ | å‚æ•°å¤„ç† | æ€§èƒ½ç‰¹ç‚¹ | æœ€ä½³åœºæ™¯ |
|---------------|----------|----------|----------|----------|
| **Statement** | æ¯æ¬¡ç¼–è¯‘ | å­—ç¬¦ä¸²æ‹¼æ¥ | çµæ´»ä½†æ…¢ | åŠ¨æ€SQLç»“æ„ |
| **PreparedStatement** | é¢„ç¼–è¯‘ç¼“å­˜ | å‚æ•°ç»‘å®š | å¿«é€Ÿå®‰å…¨ | é‡å¤æ‰§è¡ŒSQL |
| **CallableStatement** | é¢„ç¼–è¯‘ç¼“å­˜ | IN/OUTå‚æ•° | åŠŸèƒ½å®Œæ•´ | å­˜å‚¨è¿‡ç¨‹è°ƒç”¨ |

#### 3. å®‰å…¨æ€§è€ƒè™‘
```java
// SimpleStatementHandler - å­˜åœ¨SQLæ³¨å…¥é£é™©
String sql = "SELECT * FROM user WHERE id = " + userId; // å±é™©ï¼

// PreparedStatementHandler - å‚æ•°ç»‘å®šï¼Œå®‰å…¨
String sql = "SELECT * FROM user WHERE id = ?";
pstmt.setLong(1, userId); // å®‰å…¨
```

#### 4. åŠŸèƒ½éœ€æ±‚ä¸åŒ
```java
// CallableStatementHandlerç‹¬æœ‰çš„OUTå‚æ•°å¤„ç†
CallableStatement cstmt = connection.prepareCall("{call getUserInfo(?, ?)}");
cstmt.setLong(1, userId);           // INå‚æ•°
cstmt.registerOutParameter(2, Types.VARCHAR); // OUTå‚æ•°
cstmt.execute();
String result = cstmt.getString(2);  // è·å–OUTå‚æ•°å€¼
```

**è®¾è®¡ç²¾é«“**ï¼šé‡‡ç”¨ç­–ç•¥æ¨¡å¼ï¼Œè®©æ¯ç§Handlerä¸“æ³¨äºç‰¹å®šåœºæ™¯çš„æœ€ä¼˜å®ç°ï¼Œè€Œä¸æ˜¯ç”¨ä¸€ä¸ªé€šç”¨å®ç°å»å¦¥åæ‰€æœ‰åœºæ™¯ã€‚

---

### æ€è€ƒé¢˜2ï¼šRoutingStatementHandlerçš„è®¾è®¡ä½“ç°äº†ä»€ä¹ˆè®¾è®¡æ€æƒ³ï¼Ÿ

**é—®é¢˜èƒŒæ™¯**ï¼š
RoutingStatementHandlerçœ‹èµ·æ¥åªæ˜¯ä¸€ä¸ªç®€å•çš„è·¯ç”±å™¨ï¼Œä¸ºä»€ä¹ˆä¸ç›´æ¥åœ¨Executorä¸­è¿›è¡Œè·¯ç”±é€‰æ‹©ï¼Ÿ

**æ·±åº¦è§£ç­”**ï¼š

#### 1. å•ä¸€èŒè´£åŸåˆ™
```java
// å¦‚æœæ²¡æœ‰RoutingStatementHandlerï¼ŒExecutorä¼šå˜æˆè¿™æ ·ï¼š
public class SimpleExecutor extends BaseExecutor {
    @Override
    public <E> List<E> doQuery(MappedStatement ms, Object parameter, RowBounds rowBounds, 
                               ResultHandler resultHandler, BoundSql boundSql) throws SQLException {
        StatementHandler handler;
        
        // Executoréœ€è¦å…³å¿ƒStatementHandlerçš„åˆ›å»ºé€»è¾‘ - è¿åå•ä¸€èŒè´£
        switch (ms.getStatementType()) {
            case STATEMENT:
                handler = new SimpleStatementHandler(...);
                break;
            case PREPARED:
                handler = new PreparedStatementHandler(...);
                break;
            case CALLABLE:
                handler = new CallableStatementHandler(...);
                break;
            default:
                throw new ExecutorException("Unknown statement type");
        }
        
        // ... æ‰§è¡Œé€»è¾‘
    }
}
```

#### 2. å¼€é—­åŸåˆ™æ”¯æŒ
```java
// æœ‰äº†RoutingStatementHandlerï¼Œæ‰©å±•æ–°çš„StatementHandlerå˜å¾—ç®€å•
public class RoutingStatementHandler implements StatementHandler {
    public RoutingStatementHandler(Executor executor, MappedStatement ms, ...) {
        switch (ms.getStatementType()) {
            case STATEMENT:
                delegate = new SimpleStatementHandler(...);
                break;
            case PREPARED:
                delegate = new PreparedStatementHandler(...);
                break;
            case CALLABLE:
                delegate = new CallableStatementHandler(...);
                break;
            case CUSTOM:  // æ–°å¢ç±»å‹ï¼Œä¸éœ€è¦ä¿®æ”¹Executor
                delegate = new CustomStatementHandler(...);
                break;
            default:
                throw new ExecutorException("Unknown statement type");
        }
    }
}
```

#### 3. å§”æ‰˜æ¨¡å¼çš„å¨åŠ›
```java
// RoutingStatementHandleræœ¬èº«ä¸å®ç°å…·ä½“é€»è¾‘ï¼Œåªè´Ÿè´£å§”æ‰˜
public class RoutingStatementHandler implements StatementHandler {
    private final StatementHandler delegate;
    
    @Override
    public Statement prepare(Connection connection, Integer transactionTimeout) throws SQLException {
        return delegate.prepare(connection, transactionTimeout); // çº¯å§”æ‰˜
    }
    
    @Override
    public void parameterize(Statement statement) throws SQLException {
        delegate.parameterize(statement); // çº¯å§”æ‰˜
    }
    
    // æ‰€æœ‰æ–¹æ³•éƒ½æ˜¯çº¯å§”æ‰˜ï¼Œè·¯ç”±å™¨çš„èŒè´£å•ä¸€ä¸”æ¸…æ™°
}
```

#### 4. æ’ä»¶æ‹¦æˆªçš„ç»Ÿä¸€å…¥å£
```java
// æ’ä»¶å¯ä»¥ç»Ÿä¸€æ‹¦æˆªRoutingStatementHandlerï¼Œè€Œä¸éœ€è¦åˆ†åˆ«æ‹¦æˆªä¸‰ç§Handler
@Intercepts({
    @Signature(type = StatementHandler.class, method = "prepare", args = {Connection.class, Integer.class}),
    @Signature(type = StatementHandler.class, method = "parameterize", args = {Statement.class})
})
public class StatementInterceptor implements Interceptor {
    @Override
    public Object intercept(Invocation invocation) throws Throwable {
        // ç»Ÿä¸€æ‹¦æˆªç‚¹ï¼Œæ— è®ºåº•å±‚æ˜¯å“ªç§Handler
        StatementHandler statementHandler = (StatementHandler) invocation.getTarget();
        // ... æ‹¦æˆªé€»è¾‘
        return invocation.proceed();
    }
}
```

**è®¾è®¡ç²¾é«“**ï¼šRoutingStatementHandlerä½“ç°äº†"ç»„åˆä¼˜äºç»§æ‰¿"çš„æ€æƒ³ï¼Œé€šè¿‡å§”æ‰˜æ¨¡å¼å®ç°äº†è·¯ç”±èŒè´£ä¸æ‰§è¡ŒèŒè´£çš„åˆ†ç¦»ã€‚

---

### æ€è€ƒé¢˜3:CallableStatementHandlerå¦‚ä½•å¤„ç†å­˜å‚¨è¿‡ç¨‹çš„è¾“å‡ºå‚æ•°?ä¸æ™®é€šæŸ¥è¯¢æœ‰ä»€ä¹ˆåŒºåˆ«?

**é—®é¢˜èƒŒæ™¯**:
CallableStatementHandleræ˜¯ä¸“é—¨ç”¨äºè°ƒç”¨æ•°æ®åº“å­˜å‚¨è¿‡ç¨‹çš„å¤„ç†å™¨,å®ƒå¦‚ä½•å¤„ç†å­˜å‚¨è¿‡ç¨‹ç‰¹æœ‰çš„è¾“å‡ºå‚æ•°?

**æ·±åº¦è§£ç­”**:

#### 1. è¾“å‡ºå‚æ•°æ³¨å†Œ

CallableStatementHandleréœ€è¦æ³¨å†Œå­˜å‚¨è¿‡ç¨‹çš„è¾“å‡ºå‚æ•°ã€‚

```
CallableStatement cstmt = connection.prepareCall("{call getUserInfo(?, ?)}");
cstmt.setLong(1, userId);           // INå‚æ•°
cstmt.registerOutParameter(2, Types.VARCHAR); // OUTå‚æ•°
cstmt.execute();
String result = cstmt.getString(2);  // è·å–OUTå‚æ•°å€¼
```

#### 2. å¤šç»“æœé›†æ”¯æŒ

CallableStatementHandleræ”¯æŒå­˜å‚¨è¿‡ç¨‹è¿”å›çš„å¤šä¸ªç»“æœé›†,è¿™åœ¨å¤æ‚æŸ¥è¯¢åœºæ™¯éå¸¸æœ‰ç”¨ã€‚å¤šç»“æœé›†éœ€è¦ ResultSetHandler.handleMultipleResults å¤„ç†ã€‚

```
// å­˜å‚¨è¿‡ç¨‹è¿”å›å¤šç»“æœé›†çš„å¤„ç†ç¤ºä¾‹
CallableStatement cs = connection.prepareCall("{CALL getUserOrders(?, ?)}");
cs.setLong(1, userId);
cs.registerOutParameter(2, Types.INTEGER); // æ³¨å†Œè¾“å‡ºå‚æ•°
cs.execute();

// å¤„ç†ç¬¬ä¸€ä¸ªç»“æœé›†(ç”¨æˆ·ä¿¡æ¯)
ResultSet rs1 = cs.getResultSet();
while (rs1.next()) {
    System.out.println("ç”¨æˆ·: " + rs1.getString("name"));
}

// åˆ‡æ¢åˆ°ä¸‹ä¸€ä¸ªç»“æœé›†(è®¢å•åˆ—è¡¨)
if (cs.getMoreResults()) {
    ResultSet rs2 = cs.getResultSet();
    while (rs2.next()) {
        System.out.println("è®¢å•: " + rs2.getLong("order_id"));
    }
}

// è·å–è¾“å‡ºå‚æ•°
int totalOrders = cs.getInt(2);
System.out.println("è®¢å•æ€»æ•°: " + totalOrders);
```

**ParameterHandlerçš„æ‰©å±•**: CallableStatementHandleréœ€è¦æ‰©å±•ParameterHandleræ¥å¤„ç†è¾“å‡ºå‚æ•°çš„æ³¨å†Œå’Œè·å–ã€‚

```
