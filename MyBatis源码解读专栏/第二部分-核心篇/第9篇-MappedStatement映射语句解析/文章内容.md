> # ç¬¬9ç¯‡ï¼šMappedStatementæ˜ å°„è¯­å¥è§£æ

## å‰è¨€

åœ¨å‰é¢çš„ç« èŠ‚ä¸­,æˆ‘ä»¬å·²ç»æ·±å…¥å­¦ä¹ äº† MyBatis çš„æ ¸å¿ƒæ‰§è¡Œç»„ä»¶:Executorã€StatementHandlerã€ParameterHandler å’Œ ResultSetHandlerã€‚è¿™äº›ç»„ä»¶åœ¨æ‰§è¡Œè¿‡ç¨‹ä¸­éƒ½éœ€è¦ä¾èµ–ä¸€ä¸ªå…³é”®çš„é…ç½®å¯¹è±¡ â€”â€” **MappedStatement**ã€‚

`MappedStatement` æ˜¯å¯¹å•æ¡ SQL æ˜ å°„è¯­å¥çš„å®Œæ•´æè¿°,å®ƒåƒæ˜¯ä¸€å¼ "æ‰§è¡Œè“å›¾",åŒ…å«äº† SQL æ¥æºã€å‚æ•°æ˜ å°„ã€ç»“æœæ˜ å°„ã€ç¼“å­˜ç­–ç•¥ç­‰æ‰€æœ‰æ‰§è¡Œæ‰€éœ€çš„ä¿¡æ¯ã€‚ç†è§£ `MappedStatement` çš„æ„å»ºå’Œä½¿ç”¨,æ˜¯æŒæ¡ MyBatis å·¥ä½œåŸç†çš„å…³é”®ä¸€ç¯ã€‚

### æœ¬ç¯‡åœ¨æ•´ä½“æ¶æ„ä¸­çš„ä½ç½®

```mermaid
graph TB
    A[é…ç½®è§£æ<br/>ç¬¬2ç¯‡] --> B[MappedStatementæ„å»º<br/>æœ¬ç¯‡æ ¸å¿ƒ]
    B --> C[SqlSessionè·å–Mapper<br/>ç¬¬3-4ç¯‡]
    C --> D[Executoræ‰§è¡Œ<br/>ç¬¬5ç¯‡]
    D --> E[è·å–MappedStatement]
    E --> F[getBoundSqlç”ŸæˆSQL]
    F --> G[StatementHandler<br/>ç¬¬6ç¯‡]
    G --> H[ParameterHandler<br/>ç¬¬7ç¯‡]
    G --> I[ResultSetHandler<br/>ç¬¬8ç¯‡]
  
    style B fill:#f9f,stroke:#333,stroke-width:4px
    style E fill:#f9f,stroke:#333,stroke-width:3px
    style F fill:#f9f,stroke:#333,stroke-width:3px
```

### ä¸å‰åºç« èŠ‚çš„å…³è”

- **ç¬¬2ç¯‡(é…ç½®ç³»ç»Ÿ)**ï¼šå­¦ä¹ äº†å¦‚ä½•è§£æ Mapper XML,æœ¬ç¯‡å°†æ·±å…¥äº†è§£è§£æåå¦‚ä½•æ„å»º `MappedStatement`
- **ç¬¬5ç¯‡(Executor)**ï¼šå­¦ä¹ äº†æ‰§è¡Œå™¨å¦‚ä½•ä½¿ç”¨ç¼“å­˜,æœ¬ç¯‡å°†äº†è§£ `MappedStatement` å¦‚ä½•æ§åˆ¶ç¼“å­˜ç­–ç•¥
- **ç¬¬6ç¯‡(StatementHandler)**ï¼šå­¦ä¹ äº†è¯­å¥å¤„ç†å™¨çš„å·¥ä½œæµç¨‹,æœ¬ç¯‡å°†äº†è§£å®ƒå¦‚ä½•ä» `MappedStatement` è·å– SQL
- **ç¬¬7ç¯‡(ParameterHandler)**ï¼šå­¦ä¹ äº†å‚æ•°å¤„ç†,æœ¬ç¯‡å°†äº†è§£å‚æ•°æ˜ å°„ä¿¡æ¯å¦‚ä½•å­˜å‚¨åœ¨ `MappedStatement` ä¸­
- **ç¬¬8ç¯‡(ResultSetHandler)**ï¼šå­¦ä¹ äº†ç»“æœæ˜ å°„,æœ¬ç¯‡å°†äº†è§£ç»“æœæ˜ å°„é…ç½®å¦‚ä½•å…³è”åˆ° `MappedStatement`

## 1. å­¦ä¹ ç›®æ ‡ç¡®è®¤

### 1.0 ç¬¬8ç¯‡æ€è€ƒé¢˜å›é¡¾

> ğŸ’¡ **è¯´æ˜**ï¼šç¬¬8ç¯‡æ€è€ƒé¢˜çš„è¯¦ç»†è§£ç­”è¯·è§æ–‡æœ«**é™„å½•A**ã€‚

**æ ¸å¿ƒè¦ç‚¹å›é¡¾**ï¼š

- ParameterHandler è´Ÿè´£å…¥å‚ç»‘å®šï¼ˆJava â†’ JDBCï¼‰ï¼ŒResultSetHandler è´Ÿè´£å‡ºå‚æ˜ å°„ï¼ˆJDBC â†’ Javaï¼‰
- åµŒå¥—æŸ¥è¯¢ç®€å•ä½†å¯èƒ½ N+1ï¼ŒåµŒå¥—ç»“æœæ˜ å°„é«˜æ•ˆä½† SQL å¤æ‚
- å»¶è¿ŸåŠ è½½é€šè¿‡ä»£ç†æ‹¦æˆªå±æ€§è®¿é—®è§¦å‘æŸ¥è¯¢
- æ‰©å±• ResultSetHandler ä½¿ç”¨è£…é¥°å™¨/æ’ä»¶æ¨¡å¼
- æ€§èƒ½ä¼˜åŒ–å…³æ³¨åå°„ã€è‡ªåŠ¨æ˜ å°„ã€fetchSize ç­‰

### 1.1 æœ¬ç¯‡å­¦ä¹ ç›®æ ‡

1. æŒæ¡ `MappedStatement` çš„ç»“æ„ä¸æ„å»ºæµç¨‹ï¼ˆXML/æ³¨è§£ï¼‰
2. ç†è§£ `SqlSource` ä¸ `BoundSql` çš„åä½œä¸ `additionalParameters`
3. ç†Ÿæ‚‰è¿è¡ŒæœŸ `MappedStatement.getBoundSql(...)` çš„è°ƒç”¨é“¾ä¸ç¼“å­˜é”®ç”Ÿæˆ
4. ç†è§£ `useCache`/`flushCacheRequired`ã€`resultSets` ç­‰å…³é”®å±æ€§çš„è¡Œä¸º
5. æŒæ¡è°ƒè¯•æ–­ç‚¹ä¸å¸¸è§é—®é¢˜å®šä½æ–¹æ³•

## 2. MappedStatement æ¦‚è§ˆä¸æ ¸å¿ƒç»“æ„

### 2.1 æ ¸å¿ƒèŒè´£ä¸å®šä½

`MappedStatement` æ˜¯å¯¹å•æ¡æ˜ å°„è¯­å¥ï¼ˆselect/insert/update/deleteï¼‰çš„**å®Œæ•´æè¿°**ï¼Œå®ƒå°è£…äº†ï¼š

- âœ… **SQL æ¥æº**ï¼šé€šè¿‡ `SqlSource` æä¾›é™æ€æˆ–åŠ¨æ€ SQL
- âœ… **å‚æ•°æ˜ å°„**ï¼šå¦‚ä½•å°† Java å¯¹è±¡æ˜ å°„åˆ° SQL å‚æ•°
- âœ… **ç»“æœæ˜ å°„**ï¼šå¦‚ä½•å°† ResultSet æ˜ å°„ä¸º Java å¯¹è±¡
- âœ… **æ‰§è¡Œå±æ€§**ï¼šè¶…æ—¶ã€fetchSizeã€statementType ç­‰
- âœ… **ç¼“å­˜ç­–ç•¥**ï¼šuseCacheã€flushCacheRequired ç­‰
- âœ… **ä¸»é”®ç”Ÿæˆ**ï¼šINSERT è¯­å¥çš„ä¸»é”®å›å¡«ç­–ç•¥

### 2.2 ç±»ç»“æ„å›¾

```mermaid
classDiagram
    class MappedStatement {
        -String id
        -Configuration configuration
        -SqlSource sqlSource
        -StatementType statementType
        -SqlCommandType sqlCommandType
        -Integer fetchSize
        -Integer timeout
        -List~ResultMap~ resultMaps
        -ParameterMap parameterMap
        -KeyGenerator keyGenerator
        -String[] keyProperties
        -Cache cache
        -boolean useCache
        -boolean flushCacheRequired
        -String[] resultSets
        +getBoundSql(Object) BoundSql
    }
  
    class Builder {
        -MappedStatement mappedStatement
        +Builder(config, id, sqlSource, commandType)
        +resultMaps(List) Builder
        +useCache(boolean) Builder
        +flushCacheRequired(boolean) Builder
        +build() MappedStatement
    }
  
    class SqlSource {
        <<interface>>
        +getBoundSql(Object) BoundSql
    }
  
    class BoundSql {
        -String sql
        -List~ParameterMapping~ parameterMappings
        -Object parameterObject
        -Map additionalParameters
        +getAdditionalParameter(String) Object
    }
  
    MappedStatement ..> Builder : æ„å»º
    MappedStatement --> SqlSource : æŒæœ‰
    SqlSource ..> BoundSql : ç”Ÿæˆ
    MappedStatement ..> BoundSql : é€šè¿‡SqlSourceè·å–
```

### 2.3 æ ¸å¿ƒå±æ€§è¯¦è§£

```java
/**
 * MappedStatement æ ¸å¿ƒç»“æ„
 * 
 * æºç ä½ç½®: org.apache.ibatis.mapping.MappedStatement
 */
public final class MappedStatement {
  
    // ========== æ ‡è¯†ä¿¡æ¯ ==========
    /**
     * å”¯ä¸€æ ‡è¯†: namespace.statementId
     * ä¾‹å¦‚: "com.example.UserMapper.findById"
     */
    private String id;
  
    /**
     * èµ„æºæ–‡ä»¶è·¯å¾„(è°ƒè¯•ç”¨)
     * ä¾‹å¦‚: "mapper/UserMapper.xml"
     */
    private String resource;
  
    /**
     * æ•°æ®åº“å‚å•†æ ‡è¯†(å¤šæ•°æ®åº“æ”¯æŒ)
     * ä¾‹å¦‚: "mysql", "oracle"
     */
    private String databaseId;
  
    // ========== æ ¸å¿ƒç»„ä»¶ ==========
    /**
     * å…¨å±€é…ç½®å¯¹è±¡
     */
    private Configuration configuration;
  
    /**
     * SQL æ¥æº(åŠ¨æ€/é™æ€)
     * è¿è¡Œæ—¶è°ƒç”¨ sqlSource.getBoundSql(param) è·å–æœ€ç»ˆ SQL
     */
    private SqlSource sqlSource;
  
    // ========== æ‰§è¡Œå±æ€§ ==========
    /**
     * è¯­å¥ç±»å‹: STATEMENT(ç®€å•) / PREPARED(é¢„ç¼–è¯‘,é»˜è®¤) / CALLABLE(å­˜å‚¨è¿‡ç¨‹)
     * å†³å®šè·¯ç”±åˆ°å“ªä¸ª StatementHandler
     */
    private StatementType statementType;
  
    /**
     * SQL å‘½ä»¤ç±»å‹: SELECT / INSERT / UPDATE / DELETE
     */
    private SqlCommandType sqlCommandType;
  
    /**
     * JDBC fetchSize(æ‰¹é‡è·å–è¡Œæ•°)
     * å¤§ç»“æœé›†æ—¶é…åˆæ¸¸æ ‡ä½¿ç”¨
     */
    private Integer fetchSize;
  
    /**
     * æŸ¥è¯¢è¶…æ—¶(ç§’)
     */
    private Integer timeout;
  
    /**
     * ç»“æœé›†ç±»å‹: FORWARD_ONLY / SCROLL_INSENSITIVE / SCROLL_SENSITIVE
     */
    private ResultSetType resultSetType;
  
    // ========== æ˜ å°„é…ç½® ==========
    /**
     * ç»“æœæ˜ å°„åˆ—è¡¨(æ”¯æŒå¤šä¸ª resultMap)
     * ä¼˜å…ˆçº§: resultMap > resultType
     */
    private List<ResultMap> resultMaps;
  
    /**
     * å‚æ•°æ˜ å°„(å·²è¿‡æ—¶,ä¸æ¨èä½¿ç”¨)
     * ç°ä»£ MyBatis ä½¿ç”¨ ParameterMapping åˆ—è¡¨
     */
    private ParameterMap parameterMap;
  
    /**
     * å¤šç»“æœé›†åç§°(å­˜å‚¨è¿‡ç¨‹)
     * ä¾‹å¦‚: resultSets="users,orders"
     */
    private String[] resultSets;
  
    // ========== ç¼“å­˜ç­–ç•¥ ==========
    /**
     * å‘½åç©ºé—´çº§åˆ«çš„äºŒçº§ç¼“å­˜
     */
    private Cache cache;
  
    /**
     * æ˜¯å¦ä½¿ç”¨äºŒçº§ç¼“å­˜(ä»…å¯¹ SELECT æœ‰æ•ˆ)
     * é»˜è®¤: SELECT=true, å…¶ä»–=false
     */
    private boolean useCache;
  
    /**
     * æ‰§è¡Œåæ˜¯å¦åˆ·æ–°ç¼“å­˜
     * é»˜è®¤: SELECT=false, å…¶ä»–=true
     */
    private boolean flushCacheRequired;
  
    // ========== ä¸»é”®ç”Ÿæˆ ==========
    /**
     * ä¸»é”®ç”Ÿæˆå™¨
     * ä¾‹å¦‚: Jdbc3KeyGenerator(useGeneratedKeys=true)
     */
    private KeyGenerator keyGenerator;
  
    /**
     * ä¸»é”®å±æ€§å
     * ä¾‹å¦‚: keyProperty="id"
     */
    private String[] keyProperties;
  
    /**
     * ä¸»é”®åˆ—å
     * ä¾‹å¦‚: keyColumn="user_id"
     */
    private String[] keyColumn;
  
    // ========== æ ¸å¿ƒæ–¹æ³• ==========
    /**
     * è·å–ç»‘å®š SQL
     * 
     * @param parameterObject å‚æ•°å¯¹è±¡
     * @return BoundSql åŒ…å«æœ€ç»ˆ SQL å’Œå‚æ•°æ˜ å°„
     */
    public BoundSql getBoundSql(Object parameterObject) {
        return sqlSource.getBoundSql(parameterObject);
    }
}
```

### 2.4 Builder æ¨¡å¼æ„å»º

```java
/**
 * MappedStatement ä½¿ç”¨ Builder æ¨¡å¼æ„å»º
 * 
 * ä¼˜ç‚¹:
 * 1. å‚æ•°ä¼—å¤š,Builder æ¨¡å¼æå‡å¯è¯»æ€§
 * 2. é“¾å¼è°ƒç”¨,æµç•…æ„å»º
 * 3. æ„å»ºå®Œæˆåå¯¹è±¡ä¸å¯å˜(final class)
 */
public static class Builder {
    private MappedStatement mappedStatement = new MappedStatement();
  
    /**
     * æ„é€ å™¨:å¿…éœ€å‚æ•°
     */
    public Builder(Configuration configuration, String id, 
                   SqlSource sqlSource, SqlCommandType sqlCommandType) {
        mappedStatement.configuration = configuration;
        mappedStatement.id = id;
        mappedStatement.sqlSource = sqlSource;
        mappedStatement.sqlCommandType = sqlCommandType;
      
        // è®¾ç½®é»˜è®¤å€¼
        mappedStatement.statementType = StatementType.PREPARED;
        mappedStatement.resultSetType = ResultSetType.DEFAULT;
        mappedStatement.timeout = configuration.getDefaultStatementTimeout();
        mappedStatement.fetchSize = configuration.getDefaultFetchSize();
    }
  
    /**
     * å¯é€‰å‚æ•°:é“¾å¼è®¾ç½®
     */
    public Builder resultMaps(List<ResultMap> resultMaps) {
        mappedStatement.resultMaps = resultMaps;
        return this;
    }
  
    public Builder useCache(boolean useCache) {
        mappedStatement.useCache = useCache;
        return this;
    }
  
    public Builder flushCacheRequired(boolean flushCacheRequired) {
        mappedStatement.flushCacheRequired = flushCacheRequired;
        return this;
    }
  
    public Builder keyGenerator(KeyGenerator keyGenerator) {
        mappedStatement.keyGenerator = keyGenerator;
        return this;
    }
  
    // ... å…¶ä»– setter æ–¹æ³•
  
    /**
     * æ„å»ºæœ€ç»ˆå¯¹è±¡
     */
    public MappedStatement build() {
        assert mappedStatement.configuration != null;
        assert mappedStatement.id != null;
        assert mappedStatement.sqlSource != null;
      
        // è®¾ç½®é»˜è®¤ç¼“å­˜ç­–ç•¥
        if (mappedStatement.sqlCommandType == SqlCommandType.SELECT) {
            // SELECT é»˜è®¤ä½¿ç”¨ç¼“å­˜,ä¸åˆ·æ–°
            mappedStatement.useCache = true;
            mappedStatement.flushCacheRequired = false;
        } else {
            // INSERT/UPDATE/DELETE é»˜è®¤ä¸ä½¿ç”¨ç¼“å­˜,æ‰§è¡Œååˆ·æ–°
            mappedStatement.useCache = false;
            mappedStatement.flushCacheRequired = true;
        }
      
        return mappedStatement;
    }
}
```

### 2.1 æ„å»ºä¸è¿è¡Œæµç¨‹å›¾

```mermaid
sequenceDiagram
    participant XML as "XMLMapperBuilder"
    participant LS as "LanguageDriver/SqlSource"
    participant MS as "MappedStatement.Builder"
    participant Conf as "Configuration"
    participant Exec as "Executor"
    participant SH as "StatementHandler"
    participant PH as "ParameterHandler"
    participant RSH as "ResultSetHandler"

    XML->>LS: parse <select/insert/...> to SqlSource
    LS->>MS: new Builder(conf, id, sqlSource, commandType)
    MS->>MS: set resultMaps/parameterMap/keyGenerator/useCache/flushCache
    MS-->>Conf: build() & addMappedStatement(id, ms)

    Exec->>MS: ms.getBoundSql(parameter)
    MS->>LS: sqlSource.getBoundSql(parameter)
    LS-->>MS: BoundSql(sql + parameterMappings + additionalParameters)

    SH->>PH: setParameters(statement)
    SH->>DB: execute
    DB-->>RSH: ResultSet
    RSH-->>SH: List<E>
```

Note: `BoundSql.additionalParameters` å­˜æ”¾ `<foreach>` å±•å¼€ã€`<bind>` è®¡ç®—ã€åµŒå¥—ä¼ å‚ä¸´æ—¶å˜é‡ï¼›å–å€¼ä¼˜å…ˆäºæ™®é€šå‚æ•°ï¼Œä¿è¯åŠ¨æ€ç”Ÿæˆçš„æ•°æ®æ­£ç¡®ç»‘å®šã€‚

### 2.2 æ„å»ºæœŸ XML è§£ææºç è„‰ç»œ

æºç èŠ‚é€‰ï¼šXMLMapperBuilder.buildStatementFromContext

```java
// XMLMapperBuilder
private void buildStatementFromContext(List<XNode> list, String requiredDatabaseId) {
  for (XNode context : list) {
    final XMLStatementBuilder statementParser = new XMLStatementBuilder(configuration, builderAssistant, context,
        requiredDatabaseId);
    try {
      statementParser.parseStatementNode();
    } catch (IncompleteElementException e) {
      configuration.addIncompleteStatement(statementParser);
    }
  }
}
```

- å…¥å£ä¸é¢„å¤„ç†ï¼š`XMLMapperBuilder.parseStatementNode(XNode context)` è´Ÿè´£è¯»å– `<select|insert|update|delete>` å…ƒç´ çš„å±æ€§ä¸å­èŠ‚ç‚¹ï¼›åœ¨æ­¤ä¹‹å‰é€šè¿‡ `XMLIncludeTransformer.applyIncludes` å±•å¼€ `<sql id>` ç‰‡æ®µä¸ `<include refid>` å¼•ç”¨ã€‚
- æ•°æ®åº“å‚å•†é€‰æ‹©ï¼šå½“é…ç½®äº† `databaseId` æ—¶ï¼Œä¼˜å…ˆé€‰æ‹©åŒ¹é…çš„è¯­å¥å®šä¹‰ï¼Œé¿å…ä¸åŒæ•°æ®åº“æ–¹è¨€äº’ç›¸è¦†ç›–ã€‚
- `SqlSource` åˆ›å»ºï¼šæ ¹æ® `<select>` çš„ `lang` æˆ–é»˜è®¤ `LanguageDriver`ï¼Œè°ƒç”¨ `languageDriver.createSqlSource(configuration, context, parameterType)` ç”Ÿæˆ `SqlSource`ï¼ˆåŠ¨æ€æˆ–é™æ€ï¼‰ã€‚
- ç»“æœæ˜ å°„è§£æï¼šä¼˜å…ˆçº§ä¸º `resultMap > resultType`ï¼›è‹¥å¼•ç”¨çš„ `resultMap` æš‚æœªè§£æå®Œå…¨ï¼Œå¯èƒ½æŠ›å‡º `IncompleteElementException`ï¼Œåœ¨äºŒæ¬¡è§£æé˜¶æ®µè¡¥å…¨ã€‚
- æ„å»º `MappedStatement`ï¼šé€šè¿‡ `MapperBuilderAssistant.addMappedStatement(...)` å°†è§£æç»“æœè½å…¥ `Configuration`ï¼ŒåŒæ—¶è®¾ç½®é»˜è®¤ç­–ç•¥ï¼šSELECT é»˜è®¤ `useCache=true`ã€é SELECT é»˜è®¤ `flushCacheRequired=true`ã€‚

ç¤ºä¾‹ï¼ˆå…³é”®è°ƒç”¨é“¾ï¼Œç®€åŒ–å±•ç¤ºï¼‰ï¼š

```java
// å…³é”®è°ƒç”¨é“¾
XMLMapperBuilder.parseStatementNode(XNode context) {
  SqlSource sqlSource = languageDriver.createSqlSource(configuration, context, parameterType);
  builderAssistant.addMappedStatement(id, sqlSource, commandType, parameterMap,
    resultMap, timeout, fetchSize, statementType, useCache, flushCache, keyGenerator);
}
```

### 2.3 æ³¨è§£é©±åŠ¨ MappedStatement æ„å»º

æºç èŠ‚é€‰ï¼šMapperBuilderAssistant.addMappedStatementï¼ˆBuilderé“¾ï¼‰

```java
// MapperBuilderAssistant
public MappedStatement addMappedStatement(String id, SqlSource sqlSource, StatementType statementType,
    SqlCommandType sqlCommandType, Integer fetchSize, Integer timeout, String parameterMap, Class<?> parameterType,
    String resultMap, Class<?> resultType, ResultSetType resultSetType, boolean flushCache, boolean useCache,
    boolean resultOrdered, KeyGenerator keyGenerator, String keyProperty, String keyColumn, String databaseId,
    LanguageDriver lang, String resultSets, boolean dirtySelect) {

  id = applyCurrentNamespace(id, false);

  MappedStatement.Builder statementBuilder = new MappedStatement.Builder(configuration, id, sqlSource, sqlCommandType)
      .resource(resource).fetchSize(fetchSize).timeout(timeout).statementType(statementType)
      .keyGenerator(keyGenerator).keyProperty(keyProperty).keyColumn(keyColumn).databaseId(databaseId).lang(lang)
      .resultOrdered(resultOrdered).resultSets(resultSets)
      .resultMaps(getStatementResultMaps(resultMap, resultType, id)).resultSetType(resultSetType)
      .flushCacheRequired(flushCache).useCache(useCache).cache(currentCache).dirtySelect(dirtySelect);

  ParameterMap statementParameterMap = getStatementParameterMap(parameterMap, parameterType, id);
  if (statementParameterMap != null) {
    statementBuilder.parameterMap(statementParameterMap);
  }

  MappedStatement statement = statementBuilder.build();
  configuration.addMappedStatement(statement);
  return statement;
}
```

- å…¥å£ï¼š`MapperAnnotationBuilder.parse()` æ‰«æ Mapper æ¥å£æ–¹æ³•ä¸Šçš„æ³¨è§£ï¼ˆå¦‚ `@Select/@Insert/@Update/@Delete`ã€`@SelectProvider` ç­‰ï¼‰ï¼Œå¹¶æŒ‰æ–¹æ³•ç­¾åæ„å»º `MappedStatement`ã€‚
- ç»“æœæ˜ å°„ï¼šä½¿ç”¨ `@Results`/`@Result`/`@One`/`@Many` è£…é… `ResultMap`ï¼›æœªæ˜¾å¼æŒ‡å®šæ—¶å¯æ¨æ–­ä¸º `resultType`ã€‚
- æ‰§è¡Œå±æ€§ï¼šé€šè¿‡ `@Options` é…ç½® `useCache`ã€`flushCache`ã€`fetchSize`ã€`timeout`ã€`statementType`ã€`resultSets` ç­‰ã€‚

ç¤ºä¾‹ï¼š

```java
public interface OrderMapper {
  @Select({
    "SELECT * FROM t_order",
    "<where>",
    "  <if test=\"status != null\">status = #{status}</if>",
    "  <if test=\"userId != null\">AND user_id = #{userId}</if>",
    "</where>"
  })
  @Results(id = "orderMap", value = {
    @Result(property = "id",    column = "id",    id = true),
    @Result(property = "userId",column = "user_id"),
    @Result(property = "status",column = "status")
  })
  @Options(useCache = true, flushCache = Options.FlushCachePolicy.DEFAULT,
           statementType = StatementType.PREPARED)
  List<Order> findByStatus(@Param("status") String status, @Param("userId") Long userId);

  @SelectProvider(type = SqlProvider.class, method = "buildSql")
  List<Order> findByProvider(Map<String, Object> params);
}
```

## 3. å…³é”®å±æ€§è¯¦è§£ä¸è¡Œä¸º

- `statementType`ï¼šå†³å®šè·¯ç”±åˆ°å“ªç§ `StatementHandler`ï¼ˆ`STATEMENT`â†’ç®€å•ï¼›`PREPARED`â†’é¢„ç¼–è¯‘ï¼Œé»˜è®¤ï¼›`CALLABLE`â†’å­˜å‚¨è¿‡ç¨‹ï¼‰ã€‚
- `useCache`ï¼ˆä»…å¯¹ SELECTï¼‰ï¼šä¸ºå‘½åç©ºé—´çº§ `Cache` å¼€å…³ï¼›ç»“åˆ `resultHandler` ä½¿ç”¨æ—¶ä¼šç»•è¿‡äºŒçº§ç¼“å­˜ã€‚
- `flushCacheRequired`ï¼šè¯­å¥æ‰§è¡Œåæ˜¯å¦åˆ·æ–°å‘½åç©ºé—´ç¼“å­˜ï¼›é SELECT é»˜è®¤ trueï¼ŒSELECT å¯é…ç½®ã€‚
- `resultMaps`ï¼šç»“æœæ˜ å°„è§„åˆ™é›†ï¼Œæ”¯æŒ `association`/`collection` åµŒå¥—ã€è‡ªåŠ¨æ˜ å°„çº§åˆ«ï¼ˆç”±å…¨å±€ `autoMappingBehavior` æ§åˆ¶ï¼‰ã€‚
- `parameterMap`ï¼šå‚æ•°æ˜ å°„çš„æ—§æœºåˆ¶ï¼Œé€šå¸¸ä¸å»ºè®®ä½¿ç”¨ï¼Œç°ä»£ MyBatis é€šè¿‡ `ParameterMapping` åˆ—è¡¨ï¼ˆåœ¨ `BoundSql` ä¸­ï¼‰ç®¡ç†å‚æ•°ã€‚
- `keyGenerator`/`keyProperties`ï¼šä¸»é”®å›å¡«ç­–ç•¥ï¼ˆå¦‚ `Jdbc3KeyGenerator`ï¼‰ï¼Œå½±å“ INSERT çš„è¿”å›é”®å¤„ç†ã€‚
- `resultSets`ï¼šå¤šç»“æœé›†åæ ‡è¯†ï¼ˆå­˜å‚¨è¿‡ç¨‹ã€`statementType=CALLABLE`ï¼‰ï¼Œä¸ `ResultSetHandler.handleResultSets(...)` åä½œè§£æå¤šä¸ªç»“æœé›†ã€‚
- `fetchSize`/`timeout`ï¼šæ‰§è¡Œå™¨ä¸é©±åŠ¨çš„æ€§èƒ½/è¶…æ—¶å‚æ•°ï¼›å¤§ç»“æœé›†æ­é…æ¸¸æ ‡/æµå¼è¯»å–æ›´ä½³ã€‚

## 4. SqlSource ä¸ BoundSql æ·±åº¦è§£æ

### 4.1 SqlSource ä½“ç³»å…¨æ™¯

`SqlSource` æ˜¯ MyBatis ä¸­è´Ÿè´£æä¾› SQL çš„æ ¸å¿ƒæ¥å£,å®ƒçš„ä¸»è¦èŒè´£æ˜¯æ ¹æ®å‚æ•°å¯¹è±¡ç”Ÿæˆå¯æ‰§è¡Œçš„ `BoundSql`ã€‚

#### 4.1.1 SqlSource ç»§æ‰¿ä½“ç³»

```mermaid
classDiagram
    class SqlSource {
        <<interface>>
        +getBoundSql(Object) BoundSql
    }
  
    class DynamicSqlSource {
        -SqlNode rootSqlNode
        -Configuration configuration
        +getBoundSql(Object) BoundSql
    }
  
    class RawSqlSource {
        -SqlSource sqlSource
        +getBoundSql(Object) BoundSql
    }
  
    class StaticSqlSource {
        -String sql
        -List~ParameterMapping~ parameterMappings
        +getBoundSql(Object) BoundSql
    }
  
    class ProviderSqlSource {
        -Class providerType
        -Method providerMethod
        +getBoundSql(Object) BoundSql
    }
  
    SqlSource <|.. DynamicSqlSource : åŠ¨æ€SQL
    SqlSource <|.. RawSqlSource : é™æ€SQL(å«å ä½ç¬¦)
    SqlSource <|.. StaticSqlSource : çº¯é™æ€SQL
    SqlSource <|.. ProviderSqlSource : ç¼–ç¨‹å¼SQL
  
    RawSqlSource --> StaticSqlSource : å†…éƒ¨æŒæœ‰
```

#### 4.1.2 å››ç§å®ç°å¯¹æ¯”

| SqlSource ç±»å‹              | è§£ææ—¶æœº | è¿è¡ŒæœŸå¼€é”€ | é€‚ç”¨åœºæ™¯                              | ç¤ºä¾‹                                  |
| --------------------------- | -------- | ---------- | ------------------------------------- | ------------------------------------- |
| **StaticSqlSource**   | æ„å»ºæœŸ   | æœ€ä½       | çº¯é™æ€SQL,æ— å‚æ•°                      | `SELECT * FROM user`                |
| **RawSqlSource**      | æ„å»ºæœŸ   | ä½         | é™æ€SQL+`#{}`å ä½ç¬¦                 | `SELECT * FROM user WHERE id=#{id}` |
| **DynamicSqlSource**  | è¿è¡ŒæœŸ   | é«˜         | åŒ…å« `<if>`/`<foreach>`ç­‰åŠ¨æ€æ ‡ç­¾ | `<if test="name!=null">...</if>`    |
| **ProviderSqlSource** | è¿è¡ŒæœŸ   | ä¸­         | ä½¿ç”¨ `@SelectProvider`ç­‰æ³¨è§£        | ç¼–ç¨‹å¼æ„å»ºSQL                         |

### 4.2 StaticSqlSourceï¼šæœ€ç®€å•çš„å®ç°

```java
/**
 * é™æ€ SQL æº(ä¸å«ä»»ä½•å ä½ç¬¦)
 * 
 * æºç ä½ç½®: org.apache.ibatis.builder.StaticSqlSource
 */
public class StaticSqlSource implements SqlSource {
  
    private final String sql;
    private final List<ParameterMapping> parameterMappings;
    private final Configuration configuration;
  
    public StaticSqlSource(Configuration configuration, String sql) {
        this(configuration, sql, null);
    }
  
    public StaticSqlSource(Configuration configuration, String sql, 
                          List<ParameterMapping> parameterMappings) {
        this.sql = sql;
        this.parameterMappings = parameterMappings;
        this.configuration = configuration;
    }
  
    /**
     * ç›´æ¥è¿”å› BoundSql,æ— éœ€ä»»ä½•è¿è¡ŒæœŸè§£æ
     */
@Override
public BoundSql getBoundSql(Object parameterObject) {
        return new BoundSql(configuration, sql, parameterMappings, parameterObject);
    }
}
```

**ç‰¹ç‚¹**ï¼š

- âœ… æ€§èƒ½æœ€é«˜,æ— è¿è¡ŒæœŸå¼€é”€
- âœ… çº¿ç¨‹å®‰å…¨,å¯ç¼“å­˜å¤ç”¨
- âŒ ä¸æ”¯æŒåŠ¨æ€SQL
- âŒ ä¸æ”¯æŒå‚æ•°å ä½ç¬¦

### 4.3 RawSqlSourceï¼šé™æ€ SQL + å ä½ç¬¦

```java
/**
 * åŸå§‹ SQL æº(é™æ€SQL + #{}å ä½ç¬¦)
 * 
 * ç‰¹ç‚¹: æ„å»ºæœŸè§£æ #{},è¿è¡ŒæœŸç›´æ¥ä½¿ç”¨
 * 
 * æºç ä½ç½®: org.apache.ibatis.scripting.defaults.RawSqlSource
 */
public class RawSqlSource implements SqlSource {
  
    private final SqlSource sqlSource;
  
    /**
     * æ„é€ æ—¶ç«‹å³è§£æ
     */
    public RawSqlSource(Configuration configuration, SqlNode rootSqlNode, 
                       Class<?> parameterType) {
        // 1. åœ¨æ„å»ºæœŸå°±å®Œæˆ SqlNode æ ‘çš„å¤„ç†
        this(configuration, getSql(configuration, rootSqlNode), parameterType);
    }
  
    public RawSqlSource(Configuration configuration, String sql, 
                       Class<?> parameterType) {
        // 2. è§£æ #{} å ä½ç¬¦,ç”Ÿæˆ StaticSqlSource
        SqlSourceBuilder sqlSourceParser = new SqlSourceBuilder(configuration);
        Class<?> clazz = parameterType == null ? Object.class : parameterType;
      
        // 3. å°† #{id} è½¬ä¸º ?,å¹¶ç”Ÿæˆ ParameterMapping
        sqlSource = sqlSourceParser.parse(sql, clazz, new HashMap<>());
    }
  
    /**
     * è¿è¡ŒæœŸç›´æ¥å§”æ‰˜ç»™å†…éƒ¨çš„ StaticSqlSource
     */
    @Override
    public BoundSql getBoundSql(Object parameterObject) {
        return sqlSource.getBoundSql(parameterObject);
    }
  
    /**
     * æ„å»ºæœŸè·å–å®Œæ•´ SQL(åº”ç”¨ SqlNode æ ‘)
     */
    private static String getSql(Configuration configuration, SqlNode rootSqlNode) {
        DynamicContext context = new DynamicContext(configuration, null);
        rootSqlNode.apply(context);
        return context.getSql();
    }
}
```

**å…³é”®ç‰¹æ€§**ï¼š

```xml
<!-- ç¤ºä¾‹: è¿™ç§ SQL ä¼šè¢«è§£æä¸º RawSqlSource -->
<select id="findById" resultType="User">
    SELECT * FROM user WHERE id = #{id}
</select>

<!-- è§£æè¿‡ç¨‹ -->
æ„å»ºæœŸ: SELECT * FROM user WHERE id = #{id}
        â†“ SqlSourceBuilder.parse()
        SELECT * FROM user WHERE id = ?
        + ParameterMapping[property="id", javaType=Long, jdbcType=BIGINT]
      
è¿è¡ŒæœŸ: ç›´æ¥è¿”å› BoundSql(sql="SELECT * FROM user WHERE id = ?", ...)
```

### 4.4 DynamicSqlSourceï¼šåŠ¨æ€ SQL çš„æ ¸å¿ƒ

```java
/**
 * åŠ¨æ€ SQL æº(åŒ…å« <if>/<foreach> ç­‰æ ‡ç­¾)
 * 
 * ç‰¹ç‚¹: è¿è¡ŒæœŸæ ¹æ®å‚æ•°åŠ¨æ€ç”Ÿæˆ SQL
 * 
 * æºç ä½ç½®: org.apache.ibatis.scripting.xmltags.DynamicSqlSource
 */
public class DynamicSqlSource implements SqlSource {
  
    private final Configuration configuration;
    private final SqlNode rootSqlNode;  // SqlNode æ ‘çš„æ ¹èŠ‚ç‚¹
  
    public DynamicSqlSource(Configuration configuration, SqlNode rootSqlNode) {
        this.configuration = configuration;
        this.rootSqlNode = rootSqlNode;
    }
  
    /**
     * è¿è¡ŒæœŸåŠ¨æ€ç”Ÿæˆ SQL
     */
    @Override
    public BoundSql getBoundSql(Object parameterObject) {
        // 1. åˆ›å»ºåŠ¨æ€ä¸Šä¸‹æ–‡(ç”¨äºæ”¶é›† SQL ç‰‡æ®µå’Œå˜é‡)
  DynamicContext context = new DynamicContext(configuration, parameterObject);
      
        // 2. åº”ç”¨ SqlNode æ ‘(å¤„ç† <if>/<foreach> ç­‰,ç”Ÿæˆæœ€ç»ˆ SQL)
  rootSqlNode.apply(context);
      
        // 3. è§£æ #{} å ä½ç¬¦,ç”Ÿæˆ StaticSqlSource
  SqlSourceBuilder sqlSourceParser = new SqlSourceBuilder(configuration);
        Class<?> parameterType = parameterObject == null ? Object.class 
                                                          : parameterObject.getClass();
        SqlSource sqlSource = sqlSourceParser.parse(
            context.getSql(),           // åŠ¨æ€ç”Ÿæˆçš„ SQL
            parameterType, 
            context.getBindings()       // <foreach>/<bind> ç”Ÿæˆçš„ä¸´æ—¶å˜é‡
        );
      
        // 4. è·å– BoundSql
  BoundSql boundSql = sqlSource.getBoundSql(parameterObject);
      
        // 5. å°†ä¸´æ—¶å˜é‡å¤åˆ¶åˆ° BoundSql çš„ additionalParameters
  context.getBindings().forEach(boundSql::setAdditionalParameter);
      
  return boundSql;
    }
}
```

**æ‰§è¡Œæµç¨‹ç¤ºæ„**ï¼š

```mermaid
sequenceDiagram
    participant MS as MappedStatement
    participant DS as DynamicSqlSource
    participant DC as DynamicContext
    participant SN as SqlNodeæ ‘
    participant SSB as SqlSourceBuilder
    participant BS as BoundSql
  
    MS->>DS: getBoundSql(param)
    DS->>DC: new DynamicContext(config, param)
    DS->>SN: rootSqlNode.apply(context)
    SN->>SN: å¤„ç†<if>/<foreach>/<where>ç­‰
    SN->>DC: appendSql(ç‰‡æ®µ)
    SN-->>DS: SQLç‰‡æ®µæ”¶é›†å®Œæˆ
    DS->>SSB: parse(sql, type, bindings)
    SSB->>SSB: å°† #{} è½¬ä¸º ?
    SSB-->>DS: StaticSqlSource
    DS->>BS: sqlSource.getBoundSql(param)
    DS->>BS: å¤åˆ¶ additionalParameters
    DS-->>MS: BoundSql
```

**ç¤ºä¾‹**ï¼š

```xml
<!-- åŠ¨æ€ SQL ç¤ºä¾‹ -->
<select id="findUsers" resultType="User">
    SELECT * FROM user
    <where>
        <if test="name != null">
            AND name LIKE #{name}
        </if>
        <if test="age != null">
            AND age > #{age}
        </if>
        <if test="ids != null">
            AND id IN
            <foreach collection="ids" item="id" open="(" separator="," close=")">
                #{id}
            </foreach>
        </if>
    </where>
</select>
```

```java
// è¿è¡ŒæœŸè¡Œä¸º
Map<String, Object> param = new HashMap<>();
param.put("name", "%å¼ %");
param.put("ids", Arrays.asList(1L, 2L, 3L));

// ç¬¬ä¸€æ¬¡è°ƒç”¨
BoundSql bs1 = mappedStatement.getBoundSql(param);
// ç”Ÿæˆçš„ SQL: SELECT * FROM user WHERE name LIKE ? AND id IN (?, ?, ?)
// ParameterMappings: [name, __frch_id_0, __frch_id_1, __frch_id_2]
// AdditionalParameters: {__frch_id_0=1, __frch_id_1=2, __frch_id_2=3}

// ç¬¬äºŒæ¬¡è°ƒç”¨(å‚æ•°ä¸åŒ)
param.put("age", 18);
param.remove("ids");
BoundSql bs2 = mappedStatement.getBoundSql(param);
// ç”Ÿæˆçš„ SQL: SELECT * FROM user WHERE name LIKE ? AND age > ?
// ParameterMappings: [name, age]
// AdditionalParameters: {}
```

### 4.5 ProviderSqlSourceï¼šç¼–ç¨‹å¼ SQL

```java
/**
 * Provider SQL æº(é€šè¿‡ @SelectProvider ç­‰æ³¨è§£æä¾›)
 * 
 * æºç ä½ç½®: org.apache.ibatis.builder.annotation.ProviderSqlSource
 */
public class ProviderSqlSource implements SqlSource {
  
    private final Configuration configuration;
    private final Class<?> providerType;        // Provider ç±»
    private final Method providerMethod;        // Provider æ–¹æ³•
    private final boolean providerTakesParameterObject;
  
    /**
     * è¿è¡ŒæœŸè°ƒç”¨ Provider æ–¹æ³•ç”Ÿæˆ SQL
     */
    @Override
    public BoundSql getBoundSql(Object parameterObject) {
        // 1. è°ƒç”¨ Provider æ–¹æ³•è·å– SQL å­—ç¬¦ä¸²
        String sql;
        try {
            if (providerTakesParameterObject) {
                sql = (String) providerMethod.invoke(
                    providerType.newInstance(), 
                    parameterObject
                );
            } else {
                sql = (String) providerMethod.invoke(
                    providerType.newInstance()
                );
            }
        } catch (Exception e) {
            throw new BuilderException("Error invoking SqlProvider method", e);
        }
      
        // 2. è§£æ SQL(å¯èƒ½åŒ…å« #{})
        SqlSource sqlSource = createSqlSource(sql, parameterObject);
      
        // 3. è¿”å› BoundSql
        return sqlSource.getBoundSql(parameterObject);
    }
  
    private SqlSource createSqlSource(String sql, Object parameterObject) {
        // æ ¹æ® SQL å†…å®¹é€‰æ‹© RawSqlSource æˆ– DynamicSqlSource
        // ...
    }
}
```

**ä½¿ç”¨ç¤ºä¾‹**ï¼š

```java
/**
 * SQL Provider ç±»
 */
public class UserSqlProvider {
  
    /**
     * ç¼–ç¨‹å¼æ„å»º SQL
     */
    public String findUsers(Map<String, Object> params) {
        StringBuilder sql = new StringBuilder("SELECT * FROM user WHERE 1=1");
      
        if (params.get("name") != null) {
            sql.append(" AND name LIKE #{name}");
        }
      
        if (params.get("age") != null) {
            sql.append(" AND age > #{age}");
        }
      
        if (params.get("orderBy") != null) {
            // æ³¨æ„: ORDER BY ä¸èƒ½ç”¨ #{},è¦ç”¨ ${} æˆ–å­—ç¬¦ä¸²æ‹¼æ¥
            sql.append(" ORDER BY ").append(params.get("orderBy"));
        }
      
        return sql.toString();
    }
}

/**
 * Mapper æ¥å£
 */
public interface UserMapper {
  
    @SelectProvider(type = UserSqlProvider.class, method = "findUsers")
    List<User> findUsers(Map<String, Object> params);
}
```

### 4.6 BoundSqlï¼šæœ€ç»ˆçš„ SQL è½½ä½“

```java
/**
 * BoundSql å°è£…äº†å¯æ‰§è¡Œçš„ SQL åŠå…¶å…ƒæ•°æ®
 * 
 * æºç ä½ç½®: org.apache.ibatis.mapping.BoundSql
 */
public class BoundSql {
  
    private final String sql;  // æœ€ç»ˆ SQL(å« ? å ä½ç¬¦)
    private final List<ParameterMapping> parameterMappings;  // å‚æ•°æ˜ å°„
    private final Object parameterObject;  // ç”¨æˆ·ä¼ å…¥çš„å‚æ•°å¯¹è±¡
    private final Map<String, Object> additionalParameters;  // ä¸´æ—¶å‚æ•°(foreach/bind)
    private final MetaObject metaParameters;  // å‚æ•°å…ƒå¯¹è±¡
  
    public BoundSql(Configuration configuration, String sql,
                   List<ParameterMapping> parameterMappings, 
                   Object parameterObject) {
        this.sql = sql;
        this.parameterMappings = parameterMappings;
        this.parameterObject = parameterObject;
        this.additionalParameters = new HashMap<>();
        this.metaParameters = configuration.newMetaObject(additionalParameters);
    }
  
    // ========== Getter æ–¹æ³• ==========
  
    public String getSql() {
        return sql;
    }
  
    public List<ParameterMapping> getParameterMappings() {
        return parameterMappings;
    }
  
    public Object getParameterObject() {
        return parameterObject;
    }
  
    // ========== AdditionalParameters ç®¡ç† ==========
  
    /**
     * æ£€æŸ¥æ˜¯å¦æœ‰ä¸´æ—¶å‚æ•°
     */
    public boolean hasAdditionalParameter(String name) {
        return additionalParameters.containsKey(name);
    }
  
    /**
     * è®¾ç½®ä¸´æ—¶å‚æ•°
     * 
     * å…¸å‹åœºæ™¯:
     * - <foreach> ç”Ÿæˆçš„ __frch_xxx_0, __frch_xxx_1
     * - <bind> å®šä¹‰çš„å˜é‡
     */
    public void setAdditionalParameter(String name, Object value) {
        metaParameters.setValue(name, value);
    }
  
    /**
     * è·å–ä¸´æ—¶å‚æ•°
     */
    public Object getAdditionalParameter(String name) {
        return metaParameters.getValue(name);
    }
}
```

### 4.7 æ€§èƒ½å¯¹æ¯”ä¸é€‰æ‹©å»ºè®®

```java
/**
 * æ€§èƒ½æµ‹è¯•ç¤ºä¾‹(JMH åŸºå‡†æµ‹è¯•)
 */
@State(Scope.Thread)
public class SqlSourceBenchmark {
  
    private MappedStatement staticMs;
    private MappedStatement rawMs;
    private MappedStatement dynamicMs;
    private Map<String, Object> params;
  
    @Setup
    public void setup() {
        // åˆå§‹åŒ–ä¸‰ç§ MappedStatement
        // staticMs    -> StaticSqlSource
        // rawMs       -> RawSqlSource
        // dynamicMs   -> DynamicSqlSource
      
        params = new HashMap<>();
        params.put("id", 1L);
        params.put("name", "test");
    }
  
    @Benchmark
    public BoundSql testStatic() {
        return staticMs.getBoundSql(params);
    }
  
    @Benchmark
    public BoundSql testRaw() {
        return rawMs.getBoundSql(params);
    }
  
    @Benchmark
    public BoundSql testDynamic() {
        return dynamicMs.getBoundSql(params);
    }
}

/**
 * æµ‹è¯•ç»“æœ(ç¤ºæ„,å•ä½: ops/ms):
 * 
 * testStatic:   10,000,000  (æœ€å¿«)
 * testRaw:      10,000,000  (ä¸ Static ç›¸å½“)
 * testDynamic:     500,000  (æ…¢ 20 å€)
 * 
 * ç»“è®º:
 * - èƒ½ç”¨ RawSqlSource å°±ä¸ç”¨ DynamicSqlSource
 * - çƒ­ç‚¹æŸ¥è¯¢é¿å…ä¸å¿…è¦çš„åŠ¨æ€æ ‡ç­¾
 * - å¤æ‚åŠ¨æ€é€»è¾‘è€ƒè™‘ç”¨ ProviderSqlSource + ç¼“å­˜
 */
```

**é€‰æ‹©å»ºè®®**ï¼š

| åœºæ™¯                         | æ¨èæ–¹æ¡ˆ                        | ç†ç”±         |
| ---------------------------- | ------------------------------- | ------------ |
| çº¯é™æ€æŸ¥è¯¢                   | RawSqlSource                    | æ€§èƒ½æœ€ä¼˜     |
| ç®€å•æ¡ä»¶æŸ¥è¯¢(1-2ä¸ª `<if>`) | DynamicSqlSource                | å¯ç»´æŠ¤æ€§å¥½   |
| å¤æ‚æ¡ä»¶æŸ¥è¯¢(>5ä¸ª `<if>`)  | ProviderSqlSource               | ç¼–ç¨‹å¼æ›´çµæ´» |
| çƒ­ç‚¹æŸ¥è¯¢                     | RawSqlSource + å¤šä¸ª statement   | é¿å…åŠ¨æ€è§£æ |
| æ‰¹é‡æ“ä½œ                     | DynamicSqlSource +`<foreach>` | ç®€æ´é«˜æ•ˆ     |

### 4.1 SqlNode æ ‘å…³é”®èŠ‚ç‚¹ä¸è¡Œä¸º

- `TrimSqlNode`/`WhereSqlNode`/`SetSqlNode`ï¼šè´Ÿè´£å¤„ç†å¤šä½™çš„å‰åç¼€ï¼ˆå¦‚è‡ªåŠ¨æ·»åŠ  `WHERE`/`SET`ï¼Œå»æ‰é¦–å°¾çš„ `AND/OR`ï¼‰ã€‚
- `ChooseSqlNode`ï¼šç­‰ä»·äº `<choose>/<when>/<otherwise>`ï¼Œè¿è¡ŒæœŸæŒ‰ OGNL æ¡ä»¶é€‰æ‹©åˆ†æ”¯ã€‚
- `ForEachSqlNode`ï¼šéå†é›†åˆç”Ÿæˆç‰‡æ®µï¼Œæ”¯æŒ `item/index/collection`ï¼Œå¹¶å‘ä¸Šä¸‹æ–‡æ³¨å…¥ä¸´æ—¶å‚æ•°ï¼ˆè§ 4.2ï¼‰ã€‚
- `BindSqlNode`ï¼šæ‰§è¡Œ OGNL è¡¨è¾¾å¼å¹¶æŠŠç»“æœç»‘å®šåˆ°ä¸Šä¸‹æ–‡å˜é‡ä¸­ï¼ˆä¸´æ—¶å‚æ•°ï¼‰ã€‚
- `IfSqlNode`ï¼šæŒ‰ OGNL æ¡ä»¶å†³å®šæ˜¯å¦åŒ…å«ç‰‡æ®µã€‚

ç¤ºä¾‹ï¼ˆForEach å±•å¼€åçš„å ä½ç¬¦ç‰‡æ®µï¼Œç¤ºæ„ï¼‰ï¼š

```xml
<foreach collection="ids" item="id" open="(" separator="," close=")">
  #{id}
</foreach>
// è¿è¡ŒæœŸ â†’ SQL: IN (?, ?, ...)
// additionalParameters:
//   __frch_id_0 = 101
//   __frch_id_1 = 102
```

### 4.2 additionalParameters ç”Ÿæˆæœºåˆ¶ï¼ˆè¿è¡ŒæœŸï¼‰

æºç èŠ‚é€‰ï¼šForEachSqlNode.apply / FilteredDynamicContext.appendSql

```java
public class ForEachSqlNode implements SqlNode {
  public static final String ITEM_PREFIX = "__frch_";
  // ... existing code ...
  @Override
  public boolean apply(DynamicContext context) {
    Map<String, Object> bindings = context.getBindings();
    final Iterable<?> iterable = evaluator.evaluateIterable(collectionExpression, bindings,
        Optional.ofNullable(nullable).orElseGet(configuration::isNullableOnForEach));
    if (iterable == null || !iterable.iterator().hasNext()) {
      return true;
    }
    // ... existing code ...
    int i = 0;
    for (Object o : iterable) {
      int uniqueNumber = context.getUniqueNumber();
      // ç»‘å®š index/item ä»¥åŠå”¯ä¸€ä¸‹æ ‡åçš„ä¸´æ—¶å˜é‡
      applyIndex(context, i, uniqueNumber);
      applyItem(context, o, uniqueNumber);
      contents.apply(new FilteredDynamicContext(configuration, context, index, item, uniqueNumber));
      i++;
    }
    // ç§»é™¤ä¸´æ—¶ç»‘å®š
    context.getBindings().remove(item);
    context.getBindings().remove(index);
    return true;
  }
  private static String itemizeItem(String item, int i) {
    return ITEM_PREFIX + item + "_" + i;
  }
  // ... existing code ...
  private static class FilteredDynamicContext extends DynamicContext {
    @Override
    public void appendSql(String sql) {
      GenericTokenParser parser = new GenericTokenParser("#{", "}", content -> {
        String newContent = content.replaceFirst("^\\s*" + item + "(?![^.,:\\s])", itemizeItem(item, index));
        if (itemIndex != null && newContent.equals(content)) {
          newContent = content.replaceFirst("^\\s*" + itemIndex + "(?![^.,:\\s])", itemizeItem(itemIndex, index));
        }
        return "#{" + newContent + "}";
      });
      delegate.appendSql(parser.parse(sql));
    }
  }
}
```

- è¿è¡Œå®¹å™¨ï¼šåŠ¨æ€ SQL åœ¨ `DynamicContext` ä¸­ç´¯è®¡ `bindings`ï¼Œ`SqlNode.apply(context)` æŠŠæ–°å˜é‡å†™å…¥ï¼›æœ€ç»ˆ `SqlSourceBuilder.parse(...)` ç”Ÿæˆ `BoundSql`ï¼Œå¹¶æŠŠä¸Šä¸‹æ–‡å˜é‡æ‹·è´ä¸º `additionalParameters`ã€‚
- å‘½åçº¦å®šï¼š`ForEachSqlNode` ä»¥ `__frch_${item}_${index}` å½¢å¼ç”Ÿæˆè¿­ä»£å˜é‡ï¼›`BindSqlNode` ä½¿ç”¨ `<bind name="var" value="...">` çš„ `name` ä½œä¸ºé”®ã€‚
- å–å€¼ä¼˜å…ˆçº§ï¼š`ParameterHandler` ä¸ `Executor.createCacheKey` å‡ä¼˜å…ˆ `boundSql.hasAdditionalParameter(name)` å‘½ä¸­ä¸´æ—¶å‚æ•°ï¼Œå†å›é€€åˆ°ä¸»å‚æ•°å¯¹è±¡ã€‚

## 5. CacheKey ç”Ÿæˆä¸ç¼“å­˜åä½œ

`Executor.createCacheKey(...)` ç»„åˆå¤šå› ç´ ç”ŸæˆæŸ¥è¯¢ç¼“å­˜é”®ï¼ˆä¸€çº§/äºŒçº§ç¼“å­˜å…±ç”¨æ ¼å¼ï¼‰ï¼š

```java
// è¦ç‚¹ï¼šIDã€åˆ†é¡µã€SQLæ–‡æœ¬ã€å…¥å‚å€¼åºåˆ—ã€ç¯å¢ƒID
CacheKey cacheKey = new CacheKey();
cacheKey.update(ms.getId());
cacheKey.update(rowBounds.getOffset());
cacheKey.update(rowBounds.getLimit());
cacheKey.update(boundSql.getSql());
for (ParameterMapping pm : boundSql.getParameterMappings()) {
  if (pm.getMode() != ParameterMode.OUT) {
    Object value;
    String name = pm.getProperty();
    if (boundSql.hasAdditionalParameter(name)) {
      value = boundSql.getAdditionalParameter(name);
    } else if (parameterObject == null) {
      value = null;
    } else if (typeHandlerRegistry.hasTypeHandler(parameterObject.getClass())) {
      value = parameterObject;
    } else {
      MetaObject mo = configuration.newMetaObject(parameterObject);
      value = mo.getValue(name);
    }
    cacheKey.update(value);
  }
}
if (configuration.getEnvironment() != null) {
  cacheKey.update(configuration.getEnvironment().getId());
}
```

è¡Œä¸ºæç¤ºï¼š

- SELECT ä¸” `useCache=true` æ—¶å‚ä¸äºŒçº§ç¼“å­˜ï¼›`resultHandler` å­˜åœ¨åˆ™ç»•è¿‡äºŒçº§ç¼“å­˜ã€‚
- é SELECT æˆ– `flushCacheRequired=true` ä¼šåˆ·æ–°å‘½åç©ºé—´ç¼“å­˜ã€‚

### 5.1 ç¼“å­˜æœªå‘½ä¸­çš„å¸¸è§åŸå› ä¸ä¼˜åŒ–

- å‚æ•°ä¸ç¨³å®šï¼šåŒä¸€æ–¹æ³•ä¸åŒå‚æ•°é¡ºåº/å‘½åå¯¼è‡´å–å€¼ä¸åŒï¼ˆå°¤å…¶ Map/åŠ¨æ€å‚æ•°ï¼‰ï¼Œå»ºè®®å›ºå®šå‘½åå¹¶ä½¿ç”¨ `@Param`ã€‚
- é¢å¤–å‚æ•°å·®å¼‚ï¼šåŠ¨æ€ SQL å¯¼è‡´ `additionalParameters` ä¸ä¸€è‡´ï¼ˆå¦‚ `<foreach>` è¿­ä»£æ¬¡æ•°ä¸åŒï¼‰ï¼Œè‡ªç„¶ä¸ä¼šå‘½ä¸­ç¼“å­˜ï¼›å¯åœ¨çƒ­ç‚¹æŸ¥è¯¢ä¸­å‡å°‘ä¸å¿…è¦çš„åŠ¨æ€æ‹¼è£…ã€‚
- åˆ†é¡µç»´åº¦ï¼š`RowBounds` çš„ offset/limit å‚ä¸ç¼“å­˜é”®ï¼Œåˆ†é¡µä¸åŒä¸ä¼šå‘½ä¸­ï¼›å»ºè®®æŠŠåˆ†é¡µå‚æ•°çº³å…¥ä¸šåŠ¡ç­–ç•¥ç¼“å­˜æˆ–ä½¿ç”¨äºŒçº§ç¼“å­˜+ç»“æœå‘½ä¸­ã€‚
- ç¯å¢ƒéš”ç¦»ï¼š`Environment.id` ä¸åŒï¼ˆå¤šæ•°æ®æº/å¤šç¯å¢ƒï¼‰å¿…ç„¶ä¸å‘½ä¸­ï¼›ç¡®ä¿åœ¨åŒä¸€ç¯å¢ƒè¯„ä¼°ç¼“å­˜ã€‚
- ç»“æœå¤„ç†å™¨ï¼šä½¿ç”¨ `ResultHandler` çš„æŸ¥è¯¢ç»•è¿‡äºŒçº§ç¼“å­˜ï¼Œå¿…è¦æ—¶å‡å°‘è‡ªå®šä¹‰å¤„ç†æˆ–æ”¹ä¸ºåç½®å¤„ç†ã€‚

ä¼˜åŒ–å»ºè®®ï¼šç¨³å®š SQL æ–‡æœ¬ï¼ˆå‡å°‘åŠ¨æ€åˆ†æ”¯ï¼‰ã€å›ºå®šå‚æ•°å‘½åä¸ç±»å‹ï¼ˆæ³¨å†Œåˆé€‚çš„ `TypeHandler`ï¼‰ã€åˆç†æ‹†åˆ†æŸ¥è¯¢ï¼ˆçƒ­ç‚¹æŸ¥è¯¢é™æ€åŒ–ï¼‰ã€è¯„ä¼°ç¼“å­˜ç²’åº¦ä¸è¿‡æœŸç­–ç•¥ã€‚

## 6. ä¸æ ¸å¿ƒç»„ä»¶çš„åä½œå…³ç³»

- ä¸ `StatementHandler`ï¼šé€šè¿‡ `getBoundSql(parameter)` æä¾›æœ€ç»ˆ SQL ä¸ `ParameterMapping`ï¼›å†³å®šè·¯ç”±ï¼ˆ`statementType`ï¼‰ã€‚
- ä¸ `ParameterHandler`ï¼šæä¾› `BoundSql`ï¼Œå…¶ä¸­åŒ…å«å‚æ•°æ˜ å°„ä¸ä¸´æ—¶å‚æ•°ï¼›å‚æ•°ä¾§ä¼˜å…ˆå– `additionalParameters`ã€‚
- ä¸ `ResultSetHandler`ï¼šé€šè¿‡ `resultMaps/resultSets` æè¿°ç»“æœè§£æç­–ç•¥ï¼›å½±å“å¤šç»“æœé›†å¤„ç†ã€‚
- ä¸ `Executor`ï¼šæ§åˆ¶ç¼“å­˜ç­–ç•¥ï¼ˆ`useCache/flushCacheRequired`ï¼‰ã€ä¸»é”®ç”Ÿæˆï¼ˆ`keyGenerator`ï¼‰ã€å»¶è¿ŸåŠ è½½ï¼ˆé…åˆ `deferLoad`ï¼‰ã€‚

## 7. æ€§èƒ½ä¼˜åŒ–ä¸å¸¸è§å‘ä½

- é™æ€ä¼˜å…ˆï¼šèƒ½ç”¨ `RawSqlSource` çš„åœºæ™¯å°½é‡é¿å…åŠ¨æ€æ ‡ç­¾ï¼Œé™ä½è¿è¡ŒæœŸè§£ææˆæœ¬ã€‚
- ç²¾å‡†æ˜ å°„ï¼šåˆç†è®¾è®¡ `ResultMap`ï¼Œå‡å°‘ FULL è‡ªåŠ¨æ˜ å°„å°è¯•ï¼›å¿…è¦æ—¶å…³é—­ä¸éœ€è¦çš„è‡ªåŠ¨æ˜ å°„ï¼ˆ`NONE/PARTIAL`ï¼‰ã€‚
- å‚æ•°å‘½åï¼šOGNL è¡¨è¾¾å¼ä¸å±æ€§åä¸€è‡´ï¼Œé¿å… `BindingException`ï¼›`<foreach item/index/collection>` å‘½åè§„èŒƒç»Ÿä¸€ã€‚
- å¤šç»“æœé›†ï¼šè®¾ç½® `resultSets` ä¸ `CallableStatement` çš„è¾“å‡ºå‚æ•°æ³¨å†Œä¸€è‡´ï¼Œä¾¿äº `ResultSetHandler` æ­£ç¡®æ¶ˆè´¹ã€‚
- ç¼“å­˜ç­–ç•¥ï¼šè¯»å¤šå†™å°‘çš„æŸ¥è¯¢å¼€å¯ `useCache`ï¼Œæ›´æ–°è¯­å¥è°¨æ…é…ç½® `flushCacheRequired`ï¼›åˆ†é¡µä¸ç¯å¢ƒ ID å½±å“ç¼“å­˜é”®å‘½ä¸­ã€‚

## 8. è°ƒè¯•æŒ‡å¯¼ï¼ˆæ–­ç‚¹ä¸æ‰“å°ï¼‰

å»ºè®®æ–­ç‚¹ï¼š

- `XMLMapperBuilder.parseStatementNode(...)`ï¼ˆXMLè§£æï¼‰
- `MappedStatement.Builder.build()`ï¼ˆæ„å»ºå®Œæˆï¼‰
- `MappedStatement.getBoundSql(...)`ï¼ˆè¿è¡ŒæœŸå– SQLï¼‰
- `SqlSource.getBoundSql(...)` / `DynamicSqlSource.getBoundSql(...)`ï¼ˆåŠ¨æ€ SQL è®¡ç®—ï¼‰
- `SqlNode.apply(...)` / `SqlSourceBuilder.parse(...)`ï¼ˆå‚æ•°æ˜ å°„ç”Ÿæˆï¼‰
- `BaseExecutor.createCacheKey(...)`ï¼ˆç¼“å­˜é”®ç”Ÿæˆï¼‰

å¿«é€Ÿæ‰“å° `BoundSql` å‚æ•°æ˜ å°„ä¸ä¸´æ—¶å‚æ•°ï¼š

```java
BoundSql bs = ms.getBoundSql(param);
System.out.println("SQL=" + bs.getSql());
for (ParameterMapping pm : bs.getParameterMappings()) {
    String name = pm.getProperty();
    Object val = bs.hasAdditionalParameter(name) ? bs.getAdditionalParameter(name) :
                 (bs.getParameterObject() == null ? null :
                  configuration.newMetaObject(bs.getParameterObject()).getValue(name));
    System.out.println("param=" + name + ", value=" + val);
}
// é¢å¤–å‚æ•°ï¼ˆç¤ºä¾‹æ€§æ‰“å°ï¼‰
for (String prefix : java.util.List.of("__frch_", "_parameter", "_databaseId")) {
    // foreach/bindç­‰å¸¸è§å‰ç¼€ï¼Œå¯æ ¹æ®ä¸šåŠ¡çº¦å®šè¡¥å……
    // æ³¨æ„ï¼šBoundSqlæœªå…¬å¼€æ‰€æœ‰é”®åéå†æ¥å£ï¼Œè¿™é‡Œæ¼”ç¤ºæŒ‰çº¦å®šæ¢æµ‹
}
```

è¿›é˜¶ï¼šé€šè¿‡æ’ä»¶æ‹¦æˆª `ParameterHandler.setParameters(...)` è®°å½•æœ€ç»ˆç»‘å®šåˆ° JDBC çš„å‚æ•°å’Œå€¼ï¼Œé¿å…åå°„è¯»å–ç§æœ‰å­—æ®µã€‚

## 9. å®Œæ•´å®è·µæ¡ˆä¾‹

### 9.1 æ¡ˆä¾‹ä¸€ï¼šç”µå•†è®¢å•æŸ¥è¯¢ç³»ç»Ÿ

#### 9.1.1 ä¸šåŠ¡åœºæ™¯

å®ç°ä¸€ä¸ªçµæ´»çš„è®¢å•æŸ¥è¯¢åŠŸèƒ½,æ”¯æŒ:

- âœ… æŒ‰è®¢å•çŠ¶æ€æŸ¥è¯¢
- âœ… æŒ‰ç”¨æˆ·IDæŸ¥è¯¢
- âœ… æŒ‰æ—¶é—´èŒƒå›´æŸ¥è¯¢
- âœ… æŒ‰è®¢å•IDåˆ—è¡¨æ‰¹é‡æŸ¥è¯¢
- âœ… åˆ†é¡µå’Œæ’åº
- âœ… æ€§èƒ½ä¼˜åŒ–(äºŒçº§ç¼“å­˜)

#### 9.1.2 æ•°æ®åº“è¡¨ç»“æ„

```sql
-- è®¢å•è¡¨
CREATE TABLE t_order (
    id BIGINT PRIMARY KEY AUTO_INCREMENT COMMENT 'è®¢å•ID',
    order_no VARCHAR(32) NOT NULL COMMENT 'è®¢å•å·',
    user_id BIGINT NOT NULL COMMENT 'ç”¨æˆ·ID',
    status VARCHAR(20) NOT NULL COMMENT 'çŠ¶æ€:PENDING/PAID/SHIPPED/COMPLETED/CANCELLED',
    total_amount DECIMAL(10,2) NOT NULL COMMENT 'æ€»é‡‘é¢',
    create_time DATETIME NOT NULL COMMENT 'åˆ›å»ºæ—¶é—´',
    update_time DATETIME NOT NULL COMMENT 'æ›´æ–°æ—¶é—´',
    INDEX idx_user_id (user_id),
    INDEX idx_status (status),
    INDEX idx_create_time (create_time)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='è®¢å•è¡¨';

-- æµ‹è¯•æ•°æ®
INSERT INTO t_order (order_no, user_id, status, total_amount, create_time, update_time) VALUES
('ORD20240101001', 1, 'PAID', 299.00, '2024-01-01 10:00:00', '2024-01-01 10:05:00'),
('ORD20240101002', 1, 'SHIPPED', 599.00, '2024-01-02 11:00:00', '2024-01-02 15:00:00'),
('ORD20240101003', 2, 'PENDING', 199.00, '2024-01-03 09:00:00', '2024-01-03 09:00:00'),
('ORD20240101004', 2, 'COMPLETED', 399.00, '2024-01-04 14:00:00', '2024-01-05 10:00:00'),
('ORD20240101005', 3, 'CANCELLED', 99.00, '2024-01-05 16:00:00', '2024-01-06 09:00:00');
```

#### 9.1.3 å®ä½“ç±»

```java
package com.example.domain;

import java.math.BigDecimal;
import java.time.LocalDateTime;

/**
 * è®¢å•å®ä½“
 */
public class Order {
  
    private Long id;
    private String orderNo;
    private Long userId;
    private String status;
    private BigDecimal totalAmount;
    private LocalDateTime createTime;
    private LocalDateTime updateTime;
  
    // ========== Getter/Setter ==========
  
    public Long getId() {
        return id;
    }
  
    public void setId(Long id) {
        this.id = id;
    }
  
    public String getOrderNo() {
        return orderNo;
    }
  
    public void setOrderNo(String orderNo) {
        this.orderNo = orderNo;
    }
  
    public Long getUserId() {
        return userId;
    }
  
    public void setUserId(Long userId) {
        this.userId = userId;
    }
  
    public String getStatus() {
        return status;
    }
  
    public void setStatus(String status) {
        this.status = status;
    }
  
    public BigDecimal getTotalAmount() {
        return totalAmount;
    }
  
    public void setTotalAmount(BigDecimal totalAmount) {
        this.totalAmount = totalAmount;
    }
  
    public LocalDateTime getCreateTime() {
        return createTime;
    }
  
    public void setCreateTime(LocalDateTime createTime) {
        this.createTime = createTime;
    }
  
    public LocalDateTime getUpdateTime() {
        return updateTime;
    }
  
    public void setUpdateTime(LocalDateTime updateTime) {
        this.updateTime = updateTime;
    }
  
    @Override
    public String toString() {
        return "Order{" +
                "id=" + id +
                ", orderNo='" + orderNo + '\'' +
                ", userId=" + userId +
                ", status='" + status + '\'' +
                ", totalAmount=" + totalAmount +
                ", createTime=" + createTime +
                ", updateTime=" + updateTime +
                '}';
    }
}
```

#### 9.1.4 Mapper XML(å±•ç¤º MappedStatement çš„å„ç§ç‰¹æ€§)

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" 
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">

<mapper namespace="com.example.mapper.OrderMapper">
  
    <!-- ==================== ResultMap é…ç½® ==================== -->
  
    <resultMap id="orderMap" type="com.example.domain.Order">
        <id property="id" column="id" />
        <result property="orderNo" column="order_no" />
        <result property="userId" column="user_id" />
        <result property="status" column="status" />
        <result property="totalAmount" column="total_amount" />
        <result property="createTime" column="create_time" />
        <result property="updateTime" column="update_time" />
    </resultMap>
  
    <!-- ==================== SQL ç‰‡æ®µå¤ç”¨ ==================== -->
  
    <sql id="baseColumns">
        id, order_no, user_id, status, total_amount, create_time, update_time
    </sql>
  
    <sql id="baseWhere">
        <where>
            <if test="userId != null">
                AND user_id = #{userId}
            </if>
            <if test="status != null and status != ''">
                AND status = #{status}
            </if>
            <if test="startTime != null">
                AND create_time >= #{startTime}
            </if>
            <if test="endTime != null">
                AND create_time <= #{endTime}
            </if>
            <if test="ids != null and ids.size() > 0">
                AND id IN
                <foreach collection="ids" item="id" open="(" separator="," close=")">
                    #{id}
                </foreach>
            </if>
        </where>
    </sql>
  
    <!-- ==================== æŸ¥è¯¢è¯­å¥(å±•ç¤ºä¸åŒç‰¹æ€§) ==================== -->
  
    <!-- 
        ç¤ºä¾‹1: ç®€å•æŸ¥è¯¢(RawSqlSource)
        - statementType=PREPARED(é»˜è®¤)
        - useCache=true(SELECTé»˜è®¤)
        - flushCacheRequired=false(SELECTé»˜è®¤)
    -->
    <select id="findById" parameterType="long" resultMap="orderMap">
        SELECT <include refid="baseColumns" />
        FROM t_order
        WHERE id = #{id}
    </select>
  
    <!-- 
        ç¤ºä¾‹2: åŠ¨æ€æŸ¥è¯¢(DynamicSqlSource)
        - åŒ…å« <if>/<where> æ ‡ç­¾
        - è¿è¡ŒæœŸåŠ¨æ€ç”Ÿæˆ SQL
        - å¼€å¯äºŒçº§ç¼“å­˜
    -->
    <select id="findByCondition" parameterType="map" resultMap="orderMap" useCache="true">
        SELECT <include refid="baseColumns" />
        FROM t_order
        <include refid="baseWhere" />
        <if test="orderBy != null and orderBy != ''">
            ORDER BY ${orderBy}
        </if>
    </select>
  
    <!-- 
        ç¤ºä¾‹3: æ‰¹é‡æŸ¥è¯¢(DynamicSqlSource + foreach)
        - å±•ç¤º additionalParameters æœºåˆ¶
        - foreach ç”Ÿæˆ __frch_id_0, __frch_id_1, ...
    -->
    <select id="findByIds" parameterType="list" resultMap="orderMap">
        SELECT <include refid="baseColumns" />
        FROM t_order
        WHERE id IN
        <foreach collection="list" item="id" open="(" separator="," close=")">
            #{id}
        </foreach>
    </select>
  
    <!-- 
        ç¤ºä¾‹4: åˆ†é¡µæŸ¥è¯¢(ç»“åˆ RowBounds)
        - RowBounds å‚æ•°å½±å“ CacheKey
        - é€‚åˆç®€å•åˆ†é¡µ,å¤æ‚åœºæ™¯ç”¨æ’ä»¶
    -->
    <select id="findByPage" parameterType="map" resultMap="orderMap">
        SELECT <include refid="baseColumns" />
        FROM t_order
        <include refid="baseWhere" />
        ORDER BY create_time DESC
    </select>
  
    <!-- 
        ç¤ºä¾‹5: ç»Ÿè®¡æŸ¥è¯¢(ä¸ä½¿ç”¨ç¼“å­˜)
        - useCache=false ç¦ç”¨äºŒçº§ç¼“å­˜
        - resultType ç®€åŒ–ç»“æœæ˜ å°„
    -->
    <select id="countByCondition" parameterType="map" resultType="long" useCache="false">
        SELECT COUNT(*)
        FROM t_order
        <include refid="baseWhere" />
    </select>
  
    <!-- ==================== æ›´æ–°è¯­å¥ ==================== -->
  
    <!-- 
        ç¤ºä¾‹6: æ›´æ–°è®¢å•çŠ¶æ€
        - flushCacheRequired=true(é»˜è®¤)
        - æ‰§è¡Œåæ¸…ç©ºå‘½åç©ºé—´ç¼“å­˜
    -->
    <update id="updateStatus" parameterType="map">
        UPDATE t_order
        SET status = #{status},
            update_time = NOW()
        WHERE id = #{id}
    </update>
  
    <!-- 
        ç¤ºä¾‹7: æ‰¹é‡æ›´æ–°(åŠ¨æ€ SQL)
        - å±•ç¤º <foreach> + <set> ç»„åˆ
    -->
    <update id="batchUpdateStatus" parameterType="map">
        UPDATE t_order
        <set>
            status = #{status},
            update_time = NOW()
        </set>
        WHERE id IN
        <foreach collection="ids" item="id" open="(" separator="," close=")">
            #{id}
        </foreach>
    </update>
  
    <!-- ==================== æ’å…¥è¯­å¥ ==================== -->
  
    <!-- 
        ç¤ºä¾‹8: æ’å…¥è®¢å•(ä¸»é”®å›å¡«)
        - useGeneratedKeys=true
        - keyProperty="id" è‡ªåŠ¨å›å¡«ä¸»é”®
        - keyGenerator=Jdbc3KeyGenerator
    -->
    <insert id="insert" parameterType="com.example.domain.Order" 
            useGeneratedKeys="true" keyProperty="id">
        INSERT INTO t_order (order_no, user_id, status, total_amount, create_time, update_time)
        VALUES (#{orderNo}, #{userId}, #{status}, #{totalAmount}, NOW(), NOW())
    </insert>
  
    <!-- 
        ç¤ºä¾‹9: æ‰¹é‡æ’å…¥
        - å±•ç¤º <foreach> ç”Ÿæˆå¤šè¡Œ VALUES
    -->
    <insert id="batchInsert" parameterType="list">
        INSERT INTO t_order (order_no, user_id, status, total_amount, create_time, update_time)
        VALUES
        <foreach collection="list" item="order" separator=",">
            (#{order.orderNo}, #{order.userId}, #{order.status}, #{order.totalAmount}, NOW(), NOW())
        </foreach>
    </insert>
  
    <!-- ==================== åˆ é™¤è¯­å¥ ==================== -->
  
    <!-- 
        ç¤ºä¾‹10: åˆ é™¤è®¢å•
        - flushCacheRequired=true(é»˜è®¤)
    -->
    <delete id="deleteById" parameterType="long">
        DELETE FROM t_order WHERE id = #{id}
    </delete>

</mapper>
```

#### 9.1.5 Mapper æ¥å£

```java
package com.example.mapper;

import com.example.domain.Order;
import org.apache.ibatis.annotations.Param;
import org.apache.ibatis.session.RowBounds;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Map;

/**
 * è®¢å• Mapper æ¥å£
 */
public interface OrderMapper {
  
    /**
     * æ ¹æ®IDæŸ¥è¯¢è®¢å•
     *
     * @param id è®¢å•ID
     * @return è®¢å•å¯¹è±¡,ä¸å­˜åœ¨è¿”å›null
     */
    Order findById(@Param("id") Long id);
  
    /**
     * æŒ‰æ¡ä»¶æŸ¥è¯¢è®¢å•
     *
     * @param userId ç”¨æˆ·ID(å¯é€‰)
     * @param status è®¢å•çŠ¶æ€(å¯é€‰)
     * @param startTime å¼€å§‹æ—¶é—´(å¯é€‰)
     * @param endTime ç»“æŸæ—¶é—´(å¯é€‰)
     * @param orderBy æ’åºå­—æ®µ(å¯é€‰)
     * @return è®¢å•åˆ—è¡¨
     */
    List<Order> findByCondition(@Param("userId") Long userId,
                                @Param("status") String status,
                                @Param("startTime") LocalDateTime startTime,
                                @Param("endTime") LocalDateTime endTime,
                                @Param("orderBy") String orderBy);
  
    /**
     * æ‰¹é‡æŸ¥è¯¢è®¢å•
     *
     * @param ids è®¢å•IDåˆ—è¡¨
     * @return è®¢å•åˆ—è¡¨
     */
    List<Order> findByIds(List<Long> ids);
  
    /**
     * åˆ†é¡µæŸ¥è¯¢è®¢å•
     *
     * @param params æŸ¥è¯¢æ¡ä»¶
     * @param rowBounds åˆ†é¡µå‚æ•°
     * @return è®¢å•åˆ—è¡¨
     */
    List<Order> findByPage(Map<String, Object> params, RowBounds rowBounds);
  
    /**
     * ç»Ÿè®¡è®¢å•æ•°é‡
     *
     * @param params æŸ¥è¯¢æ¡ä»¶
     * @return è®¢å•æ•°é‡
     */
    Long countByCondition(Map<String, Object> params);
  
    /**
     * æ›´æ–°è®¢å•çŠ¶æ€
     *
     * @param id è®¢å•ID
     * @param status æ–°çŠ¶æ€
     * @return å½±å“è¡Œæ•°
     */
    int updateStatus(@Param("id") Long id, @Param("status") String status);
  
    /**
     * æ‰¹é‡æ›´æ–°è®¢å•çŠ¶æ€
     *
     * @param ids è®¢å•IDåˆ—è¡¨
     * @param status æ–°çŠ¶æ€
     * @return å½±å“è¡Œæ•°
     */
    int batchUpdateStatus(@Param("ids") List<Long> ids, @Param("status") String status);
  
    /**
     * æ’å…¥è®¢å•
     *
     * @param order è®¢å•å¯¹è±¡
     * @return å½±å“è¡Œæ•°
     */
    int insert(Order order);
  
    /**
     * æ‰¹é‡æ’å…¥è®¢å•
     *
     * @param orders è®¢å•åˆ—è¡¨
     * @return å½±å“è¡Œæ•°
     */
    int batchInsert(List<Order> orders);
  
    /**
     * åˆ é™¤è®¢å•
     *
     * @param id è®¢å•ID
     * @return å½±å“è¡Œæ•°
     */
    int deleteById(@Param("id") Long id);
}
```

#### 9.1.6 è°ƒè¯•å®æˆ˜ï¼šæŸ¥çœ‹ MappedStatement æ„å»ºè¿‡ç¨‹

```java
package com.example;

import com.example.domain.Order;
import com.example.mapper.OrderMapper;
import org.apache.ibatis.io.Resources;
import org.apache.ibatis.mapping.*;
import org.apache.ibatis.scripting.xmltags.DynamicSqlSource;
import org.apache.ibatis.scripting.defaults.RawSqlSource;
import org.apache.ibatis.session.Configuration;
import org.apache.ibatis.session.SqlSession;
import org.apache.ibatis.session.SqlSessionFactory;
import org.apache.ibatis.session.SqlSessionFactoryBuilder;

import java.io.InputStream;
import java.time.LocalDateTime;
import java.util.*;

/**
 * MappedStatement è°ƒè¯•ç¤ºä¾‹
 */
public class MappedStatementDebugDemo {
  
    public static void main(String[] args) throws Exception {
        // 1. åˆå§‹åŒ– MyBatis
        String resource = "mybatis-config.xml";
        InputStream inputStream = Resources.getResourceAsStream(resource);
        SqlSessionFactory sessionFactory = new SqlSessionFactoryBuilder().build(inputStream);
        Configuration configuration = sessionFactory.getConfiguration();
      
        System.out.println("========== ç¬¬ä¸€éƒ¨åˆ†ï¼šæŸ¥çœ‹ MappedStatement é…ç½®ä¿¡æ¯ ==========\n");
      
        // 2. è·å– MappedStatement
        String statementId = "com.example.mapper.OrderMapper.findByCondition";
        MappedStatement ms = configuration.getMappedStatement(statementId);
      
        printMappedStatementInfo(ms);
      
        System.out.println("\n========== ç¬¬äºŒéƒ¨åˆ†ï¼šæŸ¥çœ‹ SqlSource ç±»å‹ ==========\n");
      
        // 3. å¯¹æ¯”ä¸åŒ statement çš„ SqlSource ç±»å‹
        compareSqlSourceTypes(configuration);
      
        System.out.println("\n========== ç¬¬ä¸‰éƒ¨åˆ†ï¼šåŠ¨æ€ SQL ç”Ÿæˆè¿‡ç¨‹ ==========\n");
      
        // 4. åŠ¨æ€ SQL ç”Ÿæˆæ¼”ç¤º
        demonstrateDynamicSqlGeneration(configuration);
      
        System.out.println("\n========== ç¬¬å››éƒ¨åˆ†ï¼šAdditionalParameters æœºåˆ¶ ==========\n");
      
        // 5. foreach ç”Ÿæˆçš„ä¸´æ—¶å‚æ•°
        demonstrateAdditionalParameters(configuration);
      
        System.out.println("\n========== ç¬¬äº”éƒ¨åˆ†ï¼šCacheKey ç”Ÿæˆ ==========\n");
      
        // 6. ç¼“å­˜é”®ç”Ÿæˆæ¼”ç¤º
        demonstrateCacheKeyGeneration(sessionFactory);
      
        System.out.println("\n========== ç¬¬å…­éƒ¨åˆ†ï¼šå®é™…æ‰§è¡Œ ==========\n");
      
        // 7. å®é™…æ‰§è¡ŒæŸ¥è¯¢
        executeQueries(sessionFactory);
    }
  
    /**
     * æ‰“å° MappedStatement è¯¦ç»†ä¿¡æ¯
     */
    private static void printMappedStatementInfo(MappedStatement ms) {
        System.out.println("MappedStatement è¯¦ç»†ä¿¡æ¯:");
        System.out.println("  ID: " + ms.getId());
        System.out.println("  Resource: " + ms.getResource());
        System.out.println("  SqlCommandType: " + ms.getSqlCommandType());
        System.out.println("  StatementType: " + ms.getStatementType());
        System.out.println("  SqlSourceç±»å‹: " + ms.getSqlSource().getClass().getSimpleName());
        System.out.println("  UseCache: " + ms.isUseCache());
        System.out.println("  FlushCacheRequired: " + ms.isFlushCacheRequired());
        System.out.println("  Timeout: " + ms.getTimeout());
        System.out.println("  FetchSize: " + ms.getFetchSize());
      
        // ResultMap ä¿¡æ¯
        List<ResultMap> resultMaps = ms.getResultMaps();
        if (resultMaps != null && !resultMaps.isEmpty()) {
            ResultMap resultMap = resultMaps.get(0);
            System.out.println("  ResultMap ID: " + resultMap.getId());
            System.out.println("  ResultMap Type: " + resultMap.getType().getSimpleName());
        }
      
        // Cache ä¿¡æ¯
        Cache cache = ms.getCache();
        if (cache != null) {
            System.out.println("  Cache ID: " + cache.getId());
            System.out.println("  Cacheå®ç°: " + cache.getClass().getSimpleName());
        }
    }
  
    /**
     * å¯¹æ¯”ä¸åŒ statement çš„ SqlSource ç±»å‹
     */
    private static void compareSqlSourceTypes(Configuration configuration) {
        String[] statementIds = {
            "com.example.mapper.OrderMapper.findById",           // RawSqlSource
            "com.example.mapper.OrderMapper.findByCondition",    // DynamicSqlSource
            "com.example.mapper.OrderMapper.findByIds"           // DynamicSqlSource(foreach)
        };
      
        System.out.println("ä¸åŒ SQL çš„ SqlSource ç±»å‹:");
        for (String statementId : statementIds) {
            MappedStatement ms = configuration.getMappedStatement(statementId);
            SqlSource sqlSource = ms.getSqlSource();
            String sqlSourceType = sqlSource.getClass().getSimpleName();
          
            System.out.println("  " + statementId.substring(statementId.lastIndexOf('.') + 1) 
                             + " -> " + sqlSourceType);
        }
    }
  
    /**
     * æ¼”ç¤ºåŠ¨æ€ SQL ç”Ÿæˆè¿‡ç¨‹
     */
    private static void demonstrateDynamicSqlGeneration(Configuration configuration) {
        MappedStatement ms = configuration.getMappedStatement(
            "com.example.mapper.OrderMapper.findByCondition"
        );
      
        // åœºæ™¯1: åªæœ‰ userId
        System.out.println("åœºæ™¯1: åªæŸ¥è¯¢ userId=1 çš„è®¢å•");
        Map<String, Object> params1 = new HashMap<>();
        params1.put("userId", 1L);
        BoundSql bs1 = ms.getBoundSql(params1);
        printBoundSqlInfo(bs1);
      
        // åœºæ™¯2: userId + status
        System.out.println("\nåœºæ™¯2: æŸ¥è¯¢ userId=1 ä¸” status=PAID çš„è®¢å•");
        Map<String, Object> params2 = new HashMap<>();
        params2.put("userId", 1L);
        params2.put("status", "PAID");
        BoundSql bs2 = ms.getBoundSql(params2);
        printBoundSqlInfo(bs2);
      
        // åœºæ™¯3: å®Œæ•´æ¡ä»¶
        System.out.println("\nåœºæ™¯3: å®Œæ•´æ¡ä»¶æŸ¥è¯¢");
        Map<String, Object> params3 = new HashMap<>();
        params3.put("userId", 1L);
        params3.put("status", "PAID");
        params3.put("startTime", LocalDateTime.of(2024, 1, 1, 0, 0));
        params3.put("endTime", LocalDateTime.of(2024, 12, 31, 23, 59));
        params3.put("orderBy", "create_time DESC");
        BoundSql bs3 = ms.getBoundSql(params3);
        printBoundSqlInfo(bs3);
    }
  
    /**
     * æ¼”ç¤º additionalParameters æœºåˆ¶
     */
    private static void demonstrateAdditionalParameters(Configuration configuration) {
        MappedStatement ms = configuration.getMappedStatement(
            "com.example.mapper.OrderMapper.findByIds"
        );
      
        List<Long> ids = Arrays.asList(1L, 2L, 3L);
        BoundSql boundSql = ms.getBoundSql(ids);
      
        System.out.println("foreach ç”Ÿæˆçš„ SQL:");
        System.out.println("  " + boundSql.getSql());
      
        System.out.println("\nParameterMappings:");
        List<ParameterMapping> pms = boundSql.getParameterMappings();
        for (int i = 0; i < pms.size(); i++) {
            ParameterMapping pm = pms.get(i);
            String propName = pm.getProperty();
            Object value;
          
            if (boundSql.hasAdditionalParameter(propName)) {
                value = boundSql.getAdditionalParameter(propName);
                System.out.println("  [" + i + "] " + propName + " = " + value 
                                 + " (æ¥è‡ª additionalParameters)");
            } else {
                value = ids.get(i);
                System.out.println("  [" + i + "] " + propName + " = " + value 
                                 + " (æ¥è‡ª parameterObject)");
            }
        }
    }
  
    /**
     * æ¼”ç¤º CacheKey ç”Ÿæˆ
     */
    private static void demonstrateCacheKeyGeneration(SqlSessionFactory sessionFactory) {
        try (SqlSession session = sessionFactory.openSession()) {
            Configuration configuration = session.getConfiguration();
            MappedStatement ms = configuration.getMappedStatement(
                "com.example.mapper.OrderMapper.findById"
            );
          
            // ç”Ÿæˆ CacheKey
            Map<String, Object> params = new HashMap<>();
            params.put("id", 1L);
            BoundSql boundSql = ms.getBoundSql(params);
          
            // æ³¨æ„: createCacheKey æ–¹æ³•åœ¨ BaseExecutor ä¸­
            // è¿™é‡Œä»…æ¼”ç¤º CacheKey çš„ç»„æˆå› ç´ 
            System.out.println("CacheKey ç»„æˆå› ç´ :");
            System.out.println("  1. MappedStatement ID: " + ms.getId());
            System.out.println("  2. RowBounds: offset=0, limit=Integer.MAX_VALUE");
            System.out.println("  3. SQL: " + boundSql.getSql());
            System.out.println("  4. å‚æ•°å€¼: id=1");
            System.out.println("  5. Environment ID: " + configuration.getEnvironment().getId());
          
            System.out.println("\nè¯´æ˜:");
            System.out.println("  - ç›¸åŒçš„è¿™5ä¸ªå› ç´ ä¼šç”Ÿæˆç›¸åŒçš„ CacheKey");
            System.out.println("  - ä»»ä½•ä¸€ä¸ªå› ç´ ä¸åŒéƒ½ä¼šå¯¼è‡´ç¼“å­˜æœªå‘½ä¸­");
        }
    }
  
    /**
     * å®é™…æ‰§è¡ŒæŸ¥è¯¢
     */
    private static void executeQueries(SqlSessionFactory sessionFactory) {
        try (SqlSession session = sessionFactory.openSession()) {
            OrderMapper mapper = session.getMapper(OrderMapper.class);
          
            // 1. ç®€å•æŸ¥è¯¢
            System.out.println("1. æŸ¥è¯¢ID=1çš„è®¢å•:");
            Order order = mapper.findById(1L);
            System.out.println("  " + order);
          
            // 2. æ¡ä»¶æŸ¥è¯¢
            System.out.println("\n2. æŸ¥è¯¢userId=1çš„æ‰€æœ‰è®¢å•:");
            List<Order> orders = mapper.findByCondition(1L, null, null, null, null);
            orders.forEach(o -> System.out.println("  " + o));
          
            // 3. æ‰¹é‡æŸ¥è¯¢
            System.out.println("\n3. æ‰¹é‡æŸ¥è¯¢ID=1,2,3çš„è®¢å•:");
            List<Order> batchOrders = mapper.findByIds(Arrays.asList(1L, 2L, 3L));
            batchOrders.forEach(o -> System.out.println("  " + o));
          
            // 4. ç»Ÿè®¡æŸ¥è¯¢
            System.out.println("\n4. ç»Ÿè®¡userId=1çš„è®¢å•æ•°:");
            Long count = mapper.countByCondition(Collections.singletonMap("userId", 1L));
            System.out.println("  æ•°é‡: " + count);
        }
    }
  
    /**
     * æ‰“å° BoundSql ä¿¡æ¯
     */
    private static void printBoundSqlInfo(BoundSql boundSql) {
        System.out.println("  SQL: " + boundSql.getSql().replaceAll("\\s+", " ").trim());
        System.out.println("  å‚æ•°æ•°é‡: " + boundSql.getParameterMappings().size());
        List<ParameterMapping> pms = boundSql.getParameterMappings();
        for (int i = 0; i < pms.size(); i++) {
            ParameterMapping pm = pms.get(i);
            System.out.println("    [" + i + "] " + pm.getProperty());
        }
    }
}
```

#### 9.1.7 è¿è¡Œç»“æœç¤ºä¾‹

```
========== ç¬¬ä¸€éƒ¨åˆ†ï¼šæŸ¥çœ‹ MappedStatement é…ç½®ä¿¡æ¯ ==========

MappedStatement è¯¦ç»†ä¿¡æ¯:
  ID: com.example.mapper.OrderMapper.findByCondition
  Resource: mapper/OrderMapper.xml
  SqlCommandType: SELECT
  StatementType: PREPARED
  SqlSourceç±»å‹: DynamicSqlSource
  UseCache: true
  FlushCacheRequired: false
  Timeout: null
  FetchSize: null
  ResultMap ID: orderMap
  ResultMap Type: Order
  Cache ID: com.example.mapper.OrderMapper
  Cacheå®ç°: PerpetualCache

========== ç¬¬äºŒéƒ¨åˆ†ï¼šæŸ¥çœ‹ SqlSource ç±»å‹ ==========

ä¸åŒ SQL çš„ SqlSource ç±»å‹:
  findById -> RawSqlSource
  findByCondition -> DynamicSqlSource
  findByIds -> DynamicSqlSource

========== ç¬¬ä¸‰éƒ¨åˆ†ï¼šåŠ¨æ€ SQL ç”Ÿæˆè¿‡ç¨‹ ==========

åœºæ™¯1: åªæŸ¥è¯¢ userId=1 çš„è®¢å•
  SQL: SELECT id, order_no, user_id, status, total_amount, create_time, update_time FROM t_order WHERE user_id = ?
  å‚æ•°æ•°é‡: 1
    [0] userId

åœºæ™¯2: æŸ¥è¯¢ userId=1 ä¸” status=PAID çš„è®¢å•
  SQL: SELECT id, order_no, user_id, status, total_amount, create_time, update_time FROM t_order WHERE user_id = ? AND status = ?
  å‚æ•°æ•°é‡: 2
    [0] userId
    [1] status

åœºæ™¯3: å®Œæ•´æ¡ä»¶æŸ¥è¯¢
  SQL: SELECT id, order_no, user_id, status, total_amount, create_time, update_time FROM t_order WHERE user_id = ? AND status = ? AND create_time >= ? AND create_time <= ? ORDER BY create_time DESC
  å‚æ•°æ•°é‡: 4
    [0] userId
    [1] status
    [2] startTime
    [3] endTime

========== ç¬¬å››éƒ¨åˆ†ï¼šAdditionalParameters æœºåˆ¶ ==========

foreach ç”Ÿæˆçš„ SQL:
  SELECT id, order_no, user_id, status, total_amount, create_time, update_time FROM t_order WHERE id IN ( ? , ? , ? )

ParameterMappings:
  [0] __frch_id_0 = 1 (æ¥è‡ª additionalParameters)
  [1] __frch_id_1 = 2 (æ¥è‡ª additionalParameters)
  [2] __frch_id_2 = 3 (æ¥è‡ª additionalParameters)

========== ç¬¬äº”éƒ¨åˆ†ï¼šCacheKey ç”Ÿæˆ ==========

CacheKey ç»„æˆå› ç´ :
  1. MappedStatement ID: com.example.mapper.OrderMapper.findById
  2. RowBounds: offset=0, limit=Integer.MAX_VALUE
  3. SQL: SELECT id, order_no, user_id, status, total_amount, create_time, update_time FROM t_order WHERE id = ?
  4. å‚æ•°å€¼: id=1
  5. Environment ID: development

è¯´æ˜:
  - ç›¸åŒçš„è¿™5ä¸ªå› ç´ ä¼šç”Ÿæˆç›¸åŒçš„ CacheKey
  - ä»»ä½•ä¸€ä¸ªå› ç´ ä¸åŒéƒ½ä¼šå¯¼è‡´ç¼“å­˜æœªå‘½ä¸­
```

### 9.2 å®è·µç‰‡æ®µï¼šXML æ˜ å°„ä¸è¿è¡ŒæœŸå– SQL

```xml
<select id="findByStatus" parameterType="map" resultMap="orderMap" useCache="true">
  SELECT * FROM t_order
  <where>
    <if test="status != null">status = #{status}</if>
    <if test="userId != null">AND user_id = #{userId}</if>
  </where>
</select>
```

```java
// è¿è¡ŒæœŸ
MappedStatement ms = configuration.getMappedStatement("OrderMapper.findByStatus");
BoundSql bs = ms.getBoundSql(Map.of("status", "PAID", "userId", 1L));
String sql = bs.getSql();                 // å¸¦?çš„æœ€ç»ˆSQL
List<ParameterMapping> pms = bs.getParameterMappings();
```

### 9.2 å­˜å‚¨è¿‡ç¨‹ä¸å¤šç»“æœé›†

```xml
<select id="callProc" statementType="CALLABLE" resultSets="users,orders">
  {call get_user_and_orders(#{userId})}
</select>
```

ä¸ `ResultSetHandler.handleResultSets(...)` åä½œï¼ŒæŒ‰ `resultSets` é¡ºåºæ¶ˆè´¹å¤šä¸ªç»“æœé›†ã€‚

### 9.3 æ³¨è§£é©±åŠ¨ç¤ºä¾‹ï¼ˆProvider ä¸ Optionsï¼‰

```java
class SqlProvider {
  public String buildSql(Map<String,Object> p) {
    StringBuilder sb = new StringBuilder("SELECT * FROM t_order WHERE 1=1");
    if (p.get("status") != null) sb.append(" AND status = #{status}");
    if (p.get("userId") != null) sb.append(" AND user_id = #{userId}");
    return sb.toString();
  }
}

public interface OrderMapper {
  @SelectProvider(type = SqlProvider.class, method = "buildSql")
  @Options(useCache = true, flushCache = Options.FlushCachePolicy.DEFAULT,
           statementType = StatementType.PREPARED, fetchSize = 1000)
  List<Order> findBy(Map<String,Object> params);
}
```

## 10. å°ç»“

- `MappedStatement` æ˜¯â€œå•æ¡è¯­å¥çš„å®Œæ•´ç”»åƒâ€ï¼Œè´¯ç©¿æ„å»ºæœŸï¼ˆXML/æ³¨è§£è§£æï¼‰ä¸è¿è¡ŒæœŸï¼ˆå– SQLã€æ˜ å°„ä¸æ‰§è¡Œï¼‰ã€‚
- `SqlSource â†’ BoundSql â†’ ParameterMapping/additionalParameters` æ„æˆå‚æ•°ç»‘å®šçš„æ ¸å¿ƒé“¾è·¯ã€‚
- ç¼“å­˜ç­–ç•¥ã€ä¸»é”®ç”Ÿæˆã€ç»“æœæ˜ å°„ä¸è¯­å¥ç±»å‹å…±åŒå½±å“æ‰§è¡Œè·¯å¾„ä¸æ€§èƒ½è¡¨ç°ã€‚
- è°ƒè¯•å®šä½ä»¥â€œæ„å»ºâ†’è¿è¡Œâ†’ç¼“å­˜é”®â€ä¸ºä¸»çº¿è®¾ç½®æ–­ç‚¹ï¼Œç»“åˆæ‰“å° `BoundSql` ä¸å‚æ•°å€¼å¿«é€Ÿæ’éšœã€‚

---

## æ€è€ƒé¢˜

1. åœ¨è¯»å¤šå†™å°‘çš„åœºæ™¯ä¸‹ï¼Œå¦‚ä½•ç»„åˆä½¿ç”¨ `useCache` ä¸ `flushCacheRequired` è¾¾åˆ°æœ€ä¼˜çš„ç¼“å­˜æ”¶ç›Šï¼Ÿ
2. ä»€ä¹ˆæ—¶å€™åº”è¯¥ä¼˜å…ˆé€‰æ‹© `RawSqlSource` è€Œé¿å…åŠ¨æ€ SQLï¼Ÿæœ‰å“ªäº›æŠ˜ä¸­æ–¹æ¡ˆï¼Ÿ
3. `BoundSql.additionalParameters` åœ¨å“ªäº›åœºæ™¯ä¼šå‡ºç°ï¼Ÿå®ƒä»¬çš„å–å€¼ä¼˜å…ˆçº§å¦‚ä½•å½±å“å‚æ•°ç»‘å®šï¼Ÿ
4. å¦‚ä½•åˆ©ç”¨ `resultSets` æ­£ç¡®å¤„ç†å­˜å‚¨è¿‡ç¨‹è¿”å›çš„å¤šä¸ªç»“æœé›†ï¼Œå¹¶ä¿è¯ä¸ `ResultSetHandler` çš„åä½œä¸€è‡´ï¼Ÿ
5. å¦‚æœè¦è‡ªå®šä¹‰ `LanguageDriver`ï¼Œå®ƒä¼šå¦‚ä½•å½±å“ `MappedStatement` çš„æ„å»ºä¸è¿è¡ŒæœŸè¡Œä¸ºï¼Ÿ

---

## ğŸ’¬ äº¤æµä¸è®¨è®º

æ„Ÿè°¢æ‚¨é˜…è¯»æœ¬ç¯‡æ–‡ç« ï¼å¸Œæœ›è¿™ç¯‡æ·±å…¥è§£æèƒ½å¸®åŠ©æ‚¨æ›´å¥½åœ°ç†è§£ MyBatis çš„ MappedStatement æœºåˆ¶ã€‚

### ğŸ¤ æœŸå¾…æ‚¨çš„å‚ä¸

åœ¨å­¦ä¹ å’Œå®è·µè¿‡ç¨‹ä¸­ï¼Œæ‚¨å¯èƒ½ä¼šé‡åˆ°å„ç§é—®é¢˜æˆ–æœ‰ç‹¬ç‰¹çš„è§è§£ï¼Œ**æ¬¢è¿åœ¨è¯„è®ºåŒºåˆ†äº«**ï¼š

**ğŸ’¡ åˆ†äº«æ‚¨çš„ç»éªŒ**

- åœ¨å®é™…é¡¹ç›®ä¸­ä½¿ç”¨ MappedStatement çš„ç»éªŒå’ŒæŠ€å·§
- é‡åˆ°çš„æ€§èƒ½ä¼˜åŒ–æ¡ˆä¾‹
- æœ‰è¶£çš„é—®é¢˜æ’æŸ¥è¿‡ç¨‹
- å¯¹åŠ¨æ€ SQL çš„ä½¿ç”¨å¿ƒå¾—

**â“ æå‡ºæ‚¨çš„ç–‘é—®**

- æ–‡ç« ä¸­ä¸ç†è§£çš„åœ°æ–¹
- å®è·µä¸­é‡åˆ°çš„å›°éš¾
- æºç åˆ†æä¸­çš„ç–‘æƒ‘
- ç‰¹æ®Šåœºæ™¯çš„è§£å†³æ–¹æ¡ˆå’¨è¯¢

**ğŸ”§ è®¨è®ºå®é™…é—®é¢˜**

- ç¼“å­˜æœªå‘½ä¸­çš„ç–‘éš¾æ‚ç—‡
- å‚æ•°ç»‘å®šçš„ç‰¹æ®Šæƒ…å†µ
- æ€§èƒ½è°ƒä¼˜çš„å®æˆ˜ç»éªŒ
- è‡ªå®šä¹‰æ‰©å±•çš„å¼€å‘ç»éªŒ

**ğŸ“ åé¦ˆä¸å»ºè®®**

- å¯¹æ–‡ç« å†…å®¹çš„å»ºè®®
- å¸Œæœ›è¡¥å……çš„æ¡ˆä¾‹
- å¸Œæœ›æ·±å…¥è®²è§£çš„çŸ¥è¯†ç‚¹
- å¯¹ä¸“æ çš„æœŸå¾…

### ğŸŒŸ å…±åŒè¿›æ­¥

æ‚¨çš„æ¯ä¸€ä¸ªé—®é¢˜ã€æ¯ä¸€æ¬¡åˆ†äº«éƒ½å¯èƒ½å¸®åŠ©åˆ°å…¶ä»–å­¦ä¹ è€…ï¼è®©æˆ‘ä»¬ä¸€èµ·ï¼š

- ğŸ“š **æ·±å…¥å­¦ä¹ **ï¼šé€šè¿‡è®¨è®ºåŠ æ·±ç†è§£
- ğŸ¤” **æ€è€ƒæ¢ç´¢**ï¼šåœ¨äº¤æµä¸­å‘ç°æ–°æ€è·¯
- ğŸ’ª **å…±åŒæˆé•¿**ï¼šäº’ç›¸å¸®åŠ©ï¼Œå…±åŒè¿›æ­¥
- ğŸ¯ **å®æˆ˜åº”ç”¨**ï¼šå°†çŸ¥è¯†åº”ç”¨åˆ°å®é™…é¡¹ç›®

> **æ¸©é¦¨æç¤º**ï¼šå¦‚æœæ‚¨è§‰å¾—æœ¬æ–‡å¯¹æ‚¨æœ‰å¸®åŠ©ï¼Œæ¬¢è¿ç‚¹èµã€æ”¶è—ã€è½¬å‘ï¼Œè®©æ›´å¤šäººå—ç›Šï¼

æœŸå¾…åœ¨è¯„è®ºåŒºçœ‹åˆ°æ‚¨çš„åˆ†äº«ï¼ğŸ‘‡

---

## é™„å½•

### é™„å½•Aï¼šç¬¬8ç¯‡æ€è€ƒé¢˜è¯¦ç»†è§£ç­”

> æœ¬é™„å½•æä¾›ç¬¬8ç¯‡ã€ŠResultSetHandlerç»“æœé›†å¤„ç†ã€‹æ€è€ƒé¢˜çš„è¯¦ç»†è§£ç­”ã€‚

#### æ€è€ƒé¢˜1ï¼šResultSetHandlerä¸ParameterHandleræœ‰ä»€ä¹ˆæœ¬è´¨åŒºåˆ«ï¼Ÿå®ƒä»¬å¦‚ä½•åä½œå®Œæˆå®Œæ•´çš„æ•°æ®æµè½¬ï¼Ÿ

**æœ¬è´¨åŒºåˆ«**ï¼š

`ParameterHandler` å’Œ `ResultSetHandler` æ˜¯ MyBatis ä¸­å¯¹ç§°çš„ä¸¤ä¸ªç»„ä»¶ï¼Œåˆ†åˆ«è´Ÿè´£"å…¥å‚ç»‘å®š"å’Œ"å‡ºå‚æ˜ å°„"ï¼š

| ç»´åº¦ | ParameterHandler | ResultSetHandler |
|------|------------------|------------------|
| **æ–¹å‘** | Java â†’ JDBC | JDBC â†’ Java |
| **èŒè´£** | å°† Java å‚æ•°å†™å…¥ PreparedStatement | å°† ResultSet è½¬ä¸º Java å¯¹è±¡ |
| **è¾“å…¥** | BoundSql + å‚æ•°å¯¹è±¡ | ResultSet + ResultMap |
| **è¾“å‡º** | ç»‘å®šå®Œæˆçš„ PreparedStatement | Java å¯¹è±¡/é›†åˆ |
| **ç±»å‹è½¬æ¢** | ä½¿ç”¨ TypeHandler å†™å…¥ | ä½¿ç”¨ TypeHandler è¯»å– |

**åä½œæµç¨‹**ï¼š

```
åº”ç”¨å±‚è°ƒç”¨
    â†“
SqlSession.select("findById", 1L)
    â†“
Executor.query(ms, params, ...)
    â†“
åˆ›å»º StatementHandler
    â†“
ã€ParameterHandler é˜¶æ®µã€‘
    â†“
1. åˆ›å»º PreparedStatement
2. ParameterHandler.setParameters(statement)
3. éå† ParameterMapping
4. TypeHandler.setParameter(ps, index, value, jdbcType)
5. å‚æ•°ç»‘å®šå®Œæˆ
    â†“
æ‰§è¡Œ SQL (æ•°æ®åº“)
    â†“
ã€ResultSetHandler é˜¶æ®µã€‘
    â†“
1. è·å– ResultSet
2. ResultSetHandler.handleResultSets(statement)
3. éå† ResultSet è¡Œ
4. TypeHandler.getResult(rs, columnName)
5. åå°„è®¾ç½®å¯¹è±¡å±æ€§
6. ç»„è£…ç»“æœå¯¹è±¡
    â†“
è¿”å›ç»“æœç»™åº”ç”¨å±‚
```

**å…³é”®ç‚¹**ï¼š

1. **å…±äº« TypeHandler ä½“ç³»**ï¼šä¿è¯å…¥å‚å’Œå‡ºå‚çš„ç±»å‹è½¬æ¢ä¸€è‡´æ€§
   ```java
   // ParameterHandler å†™å…¥
   typeHandler.setParameter(ps, 1, userId, JdbcType.BIGINT);
   
   // ResultSetHandler è¯»å–
   Long userId = typeHandler.getResult(rs, "user_id");
   ```

2. **å…ƒä¿¡æ¯æ¥æºä¸åŒ**ï¼š
   - ParameterHandler ä» `BoundSql.getParameterMappings()` è·å–å‚æ•°ä¿¡æ¯
   - ResultSetHandler ä» `MappedStatement.getResultMaps()` è·å–ç»“æœæ˜ å°„ä¿¡æ¯

3. **éƒ½æ”¯æŒè‡ªå®šä¹‰æ‰©å±•**ï¼šé€šè¿‡å®ç°æ¥å£å¹¶æ³¨å†Œåˆ° Configuration å³å¯æ‰©å±•

---

#### æ€è€ƒé¢˜2ï¼šåµŒå¥—æŸ¥è¯¢å’ŒåµŒå¥—ç»“æœæ˜ å°„å„æœ‰ä»€ä¹ˆä¼˜ç¼ºç‚¹ï¼Ÿåœ¨ä»€ä¹ˆåœºæ™¯ä¸‹åº”è¯¥é€‰æ‹©å“ªç§æ–¹å¼ï¼Ÿ

**æ–¹å¼å¯¹æ¯”**ï¼š

| ç»´åº¦ | åµŒå¥—æŸ¥è¯¢(N+1) | åµŒå¥—ç»“æœæ˜ å°„(JOIN) |
|------|---------------|-------------------|
| **å®ç°æ–¹å¼** | `<association>` + `select` | ä¸€æ¬¡ JOIN + ç»“æœå±•å¼€ |
| **SQL æ¬¡æ•°** | 1 + N æ¬¡ | 1 æ¬¡ |
| **SQL å¤æ‚åº¦** | âœ… ç®€å•ç‹¬ç«‹ | âš ï¸ å¤æ‚ JOIN |
| **æ•°æ®ä¼ è¾“é‡** | âœ… æŒ‰éœ€åŠ è½½ | âš ï¸ è¡Œåˆ—è†¨èƒ€ |
| **ç½‘ç»œå¼€é”€** | âš ï¸ å¤šæ¬¡å¾€è¿” | âœ… ä¸€æ¬¡å¾€è¿” |
| **æ€§èƒ½** | âš ï¸ N+1 é—®é¢˜ | âœ… ä¸€æ¬¡å–é½ |
| **å»¶è¿ŸåŠ è½½** | âœ… æ”¯æŒ | âŒ ä¸æ”¯æŒ |
| **ç»´æŠ¤æ€§** | âœ… é«˜ | âš ï¸ ä½ |
| **ä¸€è‡´æ€§** | âš ï¸ å¤šæ¬¡æŸ¥è¯¢ | âœ… å•æ¬¡å¿«ç…§ |

**åµŒå¥—æŸ¥è¯¢ç¤ºä¾‹**ï¼š

```xml
<resultMap id="orderMap" type="Order">
    <id property="id" column="id"/>
    <result property="orderNo" column="order_no"/>
    <!-- åµŒå¥—æŸ¥è¯¢ï¼šå»¶è¿ŸåŠ è½½ -->
    <association property="user" column="user_id" 
                 select="com.example.UserMapper.findById"
                 fetchType="lazy"/>
</resultMap>

<select id="findById" resultMap="orderMap">
    SELECT * FROM t_order WHERE id = #{id}
</select>
```

**åµŒå¥—ç»“æœæ˜ å°„ç¤ºä¾‹**ï¼š

```xml
<resultMap id="orderMap" type="Order">
    <id property="id" column="order_id"/>
    <result property="orderNo" column="order_no"/>
    <!-- åµŒå¥—ç»“æœï¼šä¸€æ¬¡åŠ è½½ -->
    <association property="user" javaType="User">
        <id property="id" column="user_id"/>
        <result property="name" column="user_name"/>
    </association>
</resultMap>

<select id="findById" resultMap="orderMap">
    SELECT o.id as order_id, o.order_no,
           u.id as user_id, u.name as user_name
    FROM t_order o
    LEFT JOIN t_user u ON o.user_id = u.id
    WHERE o.id = #{id}
</select>
```

**é€‰æ‹©å»ºè®®**ï¼š

âœ… **é€‰æ‹©åµŒå¥—æŸ¥è¯¢**ï¼š
- å¯¹è±¡å¯¼èˆªæ€§å¼ºï¼ˆå¦‚ `order.getUser().getDepartment()`ï¼‰
- æ•°æ®é‡å°ï¼ˆ< 1000 æ¡ï¼‰
- åªéœ€å±€éƒ¨æ•°æ®
- éœ€è¦å»¶è¿ŸåŠ è½½ä¼˜åŒ–
- æŸ¥è¯¢é€»è¾‘ç‹¬ç«‹ï¼Œä¾¿äºç»´æŠ¤

âœ… **é€‰æ‹©åµŒå¥—ç»“æœæ˜ å°„**ï¼š
- æŠ¥è¡¨/åˆ—è¡¨å±•ç¤º
- å¼ºä¸€è‡´æ€§è¦æ±‚
- æ•°æ®é‡å¯æ§ï¼ˆ< 10000 æ¡ï¼‰
- JOIN ç®€å•ï¼ˆ1-2 ä¸ªè¡¨ï¼‰
- æ€§èƒ½æ•æ„Ÿåœºæ™¯

---

#### æ€è€ƒé¢˜3ï¼šå»¶è¿ŸåŠ è½½çš„å®ç°åŸç†æ˜¯ä»€ä¹ˆï¼Ÿä¸ºä»€ä¹ˆéœ€è¦ä½¿ç”¨ä»£ç†å¯¹è±¡ï¼Ÿ

**å®ç°åŸç†**ï¼š

å»¶è¿ŸåŠ è½½é€šè¿‡**ä»£ç†å¯¹è±¡**æ‹¦æˆªå±æ€§è®¿é—®ï¼Œåœ¨å®é™…è®¿é—®æ—¶æ‰è§¦å‘æ•°æ®åº“æŸ¥è¯¢ã€‚

**æ ¸å¿ƒæµç¨‹**ï¼š

```
åº”ç”¨ä»£ç : order.getUser()
    â†“
ä»£ç†å¯¹è±¡æ‹¦æˆª
    â†“
æ£€æŸ¥æ˜¯å¦å·²åŠ è½½ï¼Ÿ
    â†“ å¦
ResultLoaderMap.load("user")
    â†“
Executor æ‰§è¡ŒåµŒå¥—æŸ¥è¯¢
    â†“
SELECT * FROM t_user WHERE id = ?
    â†“
è®¾ç½® user å±æ€§
    â†“
æ ‡è®°å·²åŠ è½½
    â†“
è¿”å› User å¯¹è±¡
```

**ä»£ç†å®ç°ï¼ˆJAVASSIST/CGLIBï¼‰**ï¼š

```java
// ä»£ç†å¯¹è±¡ä¼šæ‹¦æˆª getter æ–¹æ³•
public class OrderProxy extends Order {
    private ResultLoaderMap loaderMap;
    
    @Override
    public User getUser() {
        // è§¦å‘å»¶è¿ŸåŠ è½½
        if (!loaded) {
            loaderMap.load("user");
        }
        return super.getUser();
    }
}
```

**ä¸ºä»€ä¹ˆéœ€è¦ä»£ç†å¯¹è±¡ï¼Ÿ**

âœ… **1. æ— ä¾µå…¥æ€§**
- ä¸éœ€è¦ä¿®æ”¹å®ä½“ç±»
- å¯¹ä¸šåŠ¡ä»£ç é€æ˜

âœ… **2. ç²¾ç»†æ§åˆ¶**
- æŒ‰å±æ€§ç²’åº¦åŠ è½½
- æ”¯æŒé…ç½®è§¦å‘ç­–ç•¥

âœ… **3. äº‹åŠ¡ä¸€è‡´æ€§**
- åœ¨åŒä¸€ SqlSession ä¸­æ‰§è¡Œ
- ä¿è¯æ•°æ®ä¸€è‡´æ€§

âœ… **4. æ€§èƒ½ä¼˜åŒ–**
- é¿å…åŠ è½½ä¸éœ€è¦çš„æ•°æ®
- å‡å°‘å†…å­˜å ç”¨

âœ… **5. é…ç½®çµæ´»**

```xml
<settings>
    <setting name="lazyLoadingEnabled" value="true"/>
    <setting name="aggressiveLazyLoading" value="false"/>
    <setting name="proxyFactory" value="JAVASSIST"/>
</settings>
```

**æ³¨æ„äº‹é¡¹**ï¼š

âš ï¸ **SqlSession å…³é—­åæ— æ³•å»¶è¿ŸåŠ è½½**
```java
Order order;
try (SqlSession session = sessionFactory.openSession()) {
    order = mapper.findById(1L);
}  // SqlSession å·²å…³é—­

order.getUser();  // é”™è¯¯ï¼æ— æ³•è§¦å‘æŸ¥è¯¢
```

âš ï¸ **åºåˆ—åŒ–é—®é¢˜**
- ä»£ç†å¯¹è±¡æ— æ³•ç›´æ¥åºåˆ—åŒ–
- éœ€è¦åœ¨åºåˆ—åŒ–å‰è§¦å‘åŠ è½½æˆ–ä½¿ç”¨ DTO

---

#### æ€è€ƒé¢˜4ï¼šå¦‚ä½•è®¾è®¡ä¸€ä¸ªé€šç”¨çš„ResultSetHandleræ¥æ”¯æŒå¤šç§æ‰©å±•åŠŸèƒ½ï¼ˆå¦‚è„±æ•ã€å®¡è®¡ã€ç¼“å­˜ç­‰ï¼‰ï¼Ÿ

**è®¾è®¡æ€è·¯**ï¼š

ä½¿ç”¨**è£…é¥°å™¨æ¨¡å¼**ï¼Œåœ¨ä¸ä¿®æ”¹æ ¸å¿ƒé€»è¾‘çš„å‰æä¸‹ï¼Œé€šè¿‡ç®¡é“åŒ–çš„æ‰©å±•ç‚¹å®ç°å¤šç§åŠŸèƒ½ã€‚

**æ¶æ„è®¾è®¡**ï¼š

```
DefaultResultSetHandler (æ ¸å¿ƒ)
    â†“ è£…é¥°
DesensitizeResultSetHandler (è„±æ•å±‚)
    â†“ è£…é¥°
AuditResultSetHandler (å®¡è®¡å±‚)
    â†“ è£…é¥°
CacheResultSetHandler (ç¼“å­˜å±‚)
    â†“
è¿”å›æœ€ç»ˆç»“æœ
```

**è£…é¥°å™¨å®ç°**ï¼š

```java
public abstract class ResultSetHandlerDecorator implements ResultSetHandler {
    protected final ResultSetHandler delegate;
    
    @Override
    public List<Object> handleResultSets(Statement stmt) throws SQLException {
        // 1. è°ƒç”¨åŸå§‹é€»è¾‘
        List<Object> results = delegate.handleResultSets(stmt);
        
        // 2. æ‰§è¡Œæ‰©å±•é€»è¾‘
        return processResults(results);
    }
    
    protected abstract List<Object> processResults(List<Object> results);
}

// è„±æ•æ‰©å±•
public class DesensitizeResultSetHandler extends ResultSetHandlerDecorator {
    @Override
    protected List<Object> processResults(List<Object> results) {
        for (Object obj : results) {
            desensitize(obj);  // æ‰‹æœºå·ã€èº«ä»½è¯ç­‰è„±æ•
        }
        return results;
    }
}
```

**å…³é”®è®¾è®¡è¦ç‚¹**ï¼š

1. âœ… **å•ä¸€èŒè´£**ï¼šæ¯ä¸ªè£…é¥°å™¨åªè´Ÿè´£ä¸€ç§åŠŸèƒ½
2. âœ… **èŒè´£ä¸å˜**ï¼šä¸æ”¹å˜æ ¸å¿ƒæ˜ å°„é€»è¾‘
3. âœ… **æ˜“äºæ‰©å±•**ï¼šæ–°å¢åŠŸèƒ½åªéœ€å®ç°æ–°è£…é¥°å™¨
4. âœ… **çµæ´»ç»„åˆ**ï¼šå¯è‡ªç”±ç»„åˆå¤šä¸ªè£…é¥°å™¨
5. âœ… **é€æ˜æ’æ‹”**ï¼šé€šè¿‡é…ç½®å¯ç”¨/ç¦ç”¨

**é€šè¿‡æ’ä»¶å¯ç”¨**ï¼š

```java
@Intercepts({
    @Signature(type = ResultSetHandler.class, 
               method = "handleResultSets", 
               args = {Statement.class})
})
public class ResultSetHandlerDecoratorPlugin implements Interceptor {
    @Override
    public Object intercept(Invocation invocation) throws Throwable {
        ResultSetHandler target = (ResultSetHandler) invocation.getTarget();
        
        // æ„å»ºè£…é¥°å™¨é“¾
        ResultSetHandler decorated = target;
        decorated = new DesensitizeResultSetHandler(decorated, fields);
        decorated = new AuditResultSetHandler(decorated, logger);
        
        return decorated.handleResultSets((Statement) invocation.getArgs()[0]);
    }
}
```

---

#### æ€è€ƒé¢˜5ï¼šåœ¨é«˜å¹¶å‘åœºæ™¯ä¸‹ï¼ŒResultSetHandlerçš„å“ªäº›è®¾è®¡å¯èƒ½æˆä¸ºæ€§èƒ½ç“¶é¢ˆï¼Ÿå¦‚ä½•ä¼˜åŒ–ï¼Ÿ

**ä¸»è¦ç“¶é¢ˆ**ï¼š

**1. åå°„è®¿é—®å±æ€§**
```java
// æ¯æ¬¡éƒ½è¦åå°„æŸ¥æ‰¾ setter
metaObject.setValue(property, value);
```

**ä¼˜åŒ–**ï¼š
- ç¼“å­˜åå°„ä¿¡æ¯ï¼ˆMethod/Fieldï¼‰
- ä½¿ç”¨ MethodHandle ä»£æ›¿åå°„
- å­—èŠ‚ç ç”Ÿæˆè®¿é—®å™¨

**2. è‡ªåŠ¨æ˜ å°„åˆ—æ‰«æ**
```java
// éå†æ‰€æœ‰åˆ—åŒ¹é…å±æ€§å
for (String column : columns) {
    for (String property : properties) {
        if (match(column, property)) { ... }
    }
}
```

**ä¼˜åŒ–**ï¼š
- ä½¿ç”¨ PARTIAL è‡ªåŠ¨æ˜ å°„
- é¢„æ„å»ºæ˜ å°„è¡¨å¹¶ç¼“å­˜
- æ˜¾å¼å®šä¹‰ ResultMap

**3. åµŒå¥—ç»“æœå»é‡**
```java
// é¢‘ç¹åˆ›å»ºå¯¹è±¡å’Œå»é‡
for (Row row : resultSet) {
    Order order = createOrder(row);  // å¯èƒ½é‡å¤
}
```

**ä¼˜åŒ–**ï¼š
- ä½¿ç”¨é«˜æ•ˆå»é‡ç»“æ„ï¼ˆConcurrentHashMapï¼‰
- å‡å°‘ä¸å¿…è¦çš„å¯¹è±¡åˆ›å»º

**4. è¿‡åº¦ FULL è‡ªåŠ¨æ˜ å°„**
```xml
<setting name="autoMappingBehavior" value="FULL"/>
```

**ä¼˜åŒ–**ï¼š
```xml
<setting name="autoMappingBehavior" value="PARTIAL"/>
```

**5. å¤§ç»“æœé›†ä¸€æ¬¡æ€§åŠ è½½**
```java
List<Order> orders = mapper.findAll();  // 10ä¸‡æ¡ = OOM!
```

**ä¼˜åŒ–**ï¼š
```java
// ä½¿ç”¨æ¸¸æ ‡
try (Cursor<Order> cursor = mapper.findAllCursor()) {
    for (Order order : cursor) {
        process(order);
    }
}

// æˆ– ResultHandler
mapper.findAll(new ResultHandler<Order>() {
    public void handleResult(ResultContext<Order> ctx) {
        process(ctx.getResultObject());
    }
});
```

**æ€§èƒ½ä¼˜åŒ–æ¸…å•**ï¼š

âœ… **åå°„ä¼˜åŒ–**
- [ ] ç¼“å­˜åå°„ä¿¡æ¯
- [ ] ä½¿ç”¨ MethodHandle
- [ ] è€ƒè™‘å­—èŠ‚ç ç”Ÿæˆ

âœ… **æ˜ å°„ä¼˜åŒ–**
- [ ] ä½¿ç”¨ PARTIAL æ¨¡å¼
- [ ] é¢„æ„å»ºæ˜ å°„è¡¨
- [ ] æ˜¾å¼å®šä¹‰ ResultMap

âœ… **å¤§æ•°æ®ä¼˜åŒ–**
- [ ] ä½¿ç”¨æ¸¸æ ‡/æµå¼å¤„ç†
- [ ] è®¾ç½®åˆç†çš„ fetchSize
- [ ] ä½¿ç”¨ ResultHandler

âœ… **é…ç½®ä¼˜åŒ–**
- [ ] é¿å… FULL è‡ªåŠ¨æ˜ å°„
- [ ] ç”Ÿäº§ç¯å¢ƒå…³é—­ SQL æ—¥å¿—
- [ ] åˆç†è®¾ç½®è¿æ¥æ± å‚æ•°

---

**è¯´æ˜**ï¼šä»¥ä¸Šè§£ç­”æä¾›äº†ç¬¬8ç¯‡æ€è€ƒé¢˜çš„æ ¸å¿ƒè¦ç‚¹å’Œå…³é”®ä»£ç ç¤ºä¾‹ã€‚æ›´è¯¦ç»†çš„æºç åˆ†æå’Œå®Œæ•´å®ç°ï¼Œè¯·å‚è€ƒä¸»æ–‡æ¡£ç›¸å…³ç« èŠ‚æˆ–ç‹¬ç«‹æºç åˆ†ææ–‡æ¡£ã€‚
