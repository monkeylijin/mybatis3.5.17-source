# 第4篇：Mapper 接口的动态代理机制 - 学习检验与总结

## 🎯 学习目标回顾

完成本篇后你应当能够：

1. 解释 `MapperProxy`、`MapperMethod`、`MapperRegistry` 的职责与协作。
2. 说清 `getMapper → invoke → execute → SqlSession` 的完整调用链。
3. 正确处理多参数命名（`@Param`）、集合参数（`collection/list/array`）。
4. 区分返回类型（单个/集合/Map/Cursor）与相应的执行路径。
5. 了解 XML/注解并存时的优先级与常见冲突点。

## 🔗 与第3篇的衔接复盘（简答）

1) `SqlSession` 为什么是会话边界？
- 负责一级缓存、事务、连接生命周期；Mapper 代理共享同一会话上下文。

2) 工厂到会话的创建五步是什么？
- Environment → TransactionFactory → Transaction → Executor(可被 Caching 装饰) → DefaultSqlSession。

3) 本篇新增了哪些关键对象？
- `MapperRegistry/MapperProxyFactory/MapperProxy/MapperMethod/ParamNameResolver/MethodSignature`。

## 📝 自测清单

- [ ] 画出 Mapper 动态代理的时序图（从调用到结果返回）。
- [ ] 说明 `MapperMethod` 如何依据返回值决定 `selectOne/selectList/selectMap/selectCursor`。
- [ ] 演示无 `@Param` 与有 `@Param` 的差异，解释 `arg0/param1` 的来源与风险。
- [ ] 说明 XML 与注解同名语句的覆盖规则与原因。
- [ ] 说明一级/二级缓存对 Mapper 调用结果的影响与刷新条件。

## 🔍 源码定位题

1. `Configuration#getMapper` → `MapperRegistry#getMapper` → `MapperProxyFactory#newInstance`
2. `MapperProxy#invoke`（过滤 `Object` 方法、缓存 `MapperMethod`）
3. `MapperMethod#execute`（命令类型分支、方法签名推断）
4. `DefaultSqlSession#selectList/selectOne` → `Executor#query` → `StatementHandler`

## ❓ 思考题

1. 为什么默认采用 JDK 动态代理而不是 CGLIB？在什么情况下可能考虑使用字节码增强？
2. 当接口方法返回 `Map<K,V>` 时，`@MapKey` 的作用是什么？什么情况下会选择 `selectList` + 本地汇聚而不是 `selectMap`？
3. 多数据源与多环境下，`namespace.id` 如何避免冲突？规范建议是什么？
4. 在开启二级缓存时，哪些设置会导致绕过缓存（如 `resultHandler`、存储过程出参）？
5. 接口默认方法在代理调用链中的处理方式是什么？会带来哪些扩展可能？
6. 使用 Provider 注解族时，如何组织可复用 SQL，避免复杂 `<script>` 带来的维护成本？

## ✅ 实战验证

建议完成如下验证：

1. 为同一方法提供注解与 XML 的 SQL，实现 XML 覆盖注解的验证。
2. 方法参数：对比无 `@Param` 与有 `@Param` 在 XML 中 `#{}` 的取值表现。
3. 返回类型：编写 `T`、`List<T>`、`@MapKey Map<K,T>`、`Cursor<T>` 四种方法并断点验证 `MapperMethod` 的分支。
4. 缓存：对比 `flushCache/useCache` 不同设置下的命中与刷新行为。
5. 默认方法：为 Mapper 增加一个 default 方法，验证其不触发 SQL 执行路径。
6. Provider：用 `@SelectProvider` 重写一条动态 SQL，对比性能与可维护性。

## 📌 常见坑位速查

- `Invalid bound statement`：namespace 与 id 不匹配或未加载 Mapper。
- 多参数未命名：XML 使用 `#{id}` 取不到值，应使用 `@Param("id")`。
- 注解 `<script>` 书写错误：标签漏闭合、大小写错误、动态标签拼写错误。
- 二级缓存脏读：更新语句未 `flushCache=true` 或使用了自定义 `ResultHandler`。

## 🧭 后续衔接（第5篇预告）

将切入执行器体系：`BaseExecutor` 模板方法、`Simple/Reuse/Batch` 差异、`CachingExecutor` 的装饰器实现，以及与 `StatementHandler`/`ParameterHandler`/`ResultSetHandler` 的协作细节。


