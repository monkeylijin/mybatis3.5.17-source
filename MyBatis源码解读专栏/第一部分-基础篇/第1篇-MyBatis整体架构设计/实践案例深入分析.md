# 第1篇：实践案例深入分析

## 6. 实践案例深入分析

### 6.1 跟踪一个复杂查询的执行流程

让我们通过一个更复杂的查询来深入理解 MyBatis 的执行流程：

```java
// 复杂查询示例
public class ComplexQueryExample {
    public static void main(String[] args) throws IOException {
        // 1. 创建 SqlSessionFactory
        String resource = "mybatis-config.xml";
        InputStream inputStream = Resources.getResourceAsStream(resource);
        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);
        
        // 2. 创建 SqlSession
        SqlSession session = sqlSessionFactory.openSession();
        
        // 3. 获取 Mapper
        UserMapper mapper = session.getMapper(UserMapper.class);
        
        // 4. 执行复杂查询
        Map<String, Object> params = new HashMap<>();
        params.put("name", "张三");
        params.put("age", 25);
        params.put("offset", 0);
        params.put("limit", 10);
        
        List<User> users = mapper.selectUsersByCondition(params);
        
        // 5. 关闭会话
        session.close();
    }
}
```

**执行流程详细分析**：

1. **SqlSessionFactory 创建阶段**：
   ```java
   // 1.1 创建 XMLConfigBuilder
   XMLConfigBuilder parser = new XMLConfigBuilder(inputStream, environment, properties);
   
   // 1.2 解析配置文件
   Configuration config = parser.parse();
   
   // 1.3 创建 SqlSessionFactory
   return new DefaultSqlSessionFactory(config);
   ```

2. **SqlSession 创建阶段**：
   ```java
   // 2.1 创建 Executor
   Executor executor = configuration.newExecutor(transaction, execType);
   
   // 2.2 创建 SqlSession
   return new DefaultSqlSession(configuration, executor, autoCommit);
   ```

3. **Mapper 获取阶段**：
   ```java
   // 3.1 创建 MapperProxy
   MapperProxy<T> mapperProxy = new MapperProxy<>(sqlSession, mapperInterface, methodCache);
   
   // 3.2 创建动态代理
   return (T) Proxy.newProxyInstance(mapperInterface.getClassLoader(), 
                                   new Class[] { mapperInterface }, mapperProxy);
   ```

4. **查询执行阶段**：
   ```java
   // 4.1 MapperProxy.invoke()
   MapperMethod mapperMethod = cachedMapperMethod(method);
   return mapperMethod.execute(sqlSession, args);
   
   // 4.2 MapperMethod.execute()
   Object result = sqlSession.selectOne(command.getName(), param);
   
   // 4.3 SqlSession.selectOne()
   return selectOne(statement, parameter);
   
   // 4.4 Executor.query()
   return executor.query(ms, wrapCollection(parameter), rowBounds, Executor.NO_RESULT_HANDLER);
   
   // 4.5 StatementHandler.query()
   return handler.query(stmt, resultHandler);
   ```

### 6.2 组件职责深入分析

#### SqlSession 的职责分析

```java
public class DefaultSqlSession implements SqlSession {
    private final Configuration configuration;
    private final Executor executor;
    private final boolean autoCommit;
    private boolean dirty;
    private List<Cursor<?>> cursorList;
    
    // 查询方法
    @Override
    public <T> T selectOne(String statement, Object parameter) {
        List<T> list = this.selectList(statement, parameter);
        if (list.size() == 1) {
            return list.get(0);
        } else if (list.size() > 1) {
            throw new TooManyResultsException("Expected one result (or null) to be returned by selectOne(), but found: " + list.size());
        } else {
            return null;
        }
    }
    
    // 更新方法
    @Override
    public int update(String statement, Object parameter) {
        try {
            dirty = true;
            MappedStatement ms = configuration.getMappedStatement(statement);
            return executor.update(ms, wrapCollection(parameter));
        } catch (Exception e) {
            throw ExceptionFactory.wrapException("Error updating database.  Cause: " + e, e);
        } finally {
            ErrorContext.instance().reset();
        }
    }
}
```

**职责总结**：
- 提供统一的 CRUD 操作接口
- 管理事务状态（dirty 标志）
- 委托给 Executor 执行具体操作
- 处理异常和错误上下文

#### Executor 的职责分析

```java
public abstract class BaseExecutor implements Executor {
    protected Transaction transaction;
    protected Executor wrapper;
    protected ConcurrentLinkedQueue<DeferredLoad> deferredLoads;
    protected PerpetualCache localCache;
    protected PerpetualCache localOutputParameterCache;
    protected Configuration configuration;
    protected int queryStack;
    private boolean closed;
    
    @Override
    public <E> List<E> query(MappedStatement ms, Object parameter, RowBounds rowBounds, 
                           ResultHandler resultHandler) throws SQLException {
        BoundSql boundSql = ms.getBoundSql(parameter);
        CacheKey key = createCacheKey(ms, parameter, rowBounds, boundSql);
        return query(ms, parameter, rowBounds, resultHandler, key, boundSql);
    }
    
    @SuppressWarnings("unchecked")
    @Override
    public <E> List<E> query(MappedStatement ms, Object parameter, RowBounds rowBounds, 
                           ResultHandler resultHandler, CacheKey key, BoundSql boundSql) throws SQLException {
        ErrorContext.instance().resource(ms.getResource()).activity("executing a query").object(ms.getId());
        if (closed) {
            throw new ExecutorException("Executor was closed.");
        }
        if (queryStack == 0 && ms.isFlushCacheRequired()) {
            clearLocalCache();
        }
        List<E> list;
        try {
            queryStack++;
            list = resultHandler == null ? (List<E>) localCache.getObject(key) : null;
            if (list != null) {
                handleLocallyCachedOutputParameters(ms, key, parameter, boundSql);
            } else {
                list = queryFromDatabase(ms, parameter, rowBounds, resultHandler, key, boundSql);
            }
        } finally {
            queryStack--;
        }
        if (queryStack == 0) {
            for (DeferredLoad deferredLoad : deferredLoads) {
                deferredLoad.load();
            }
            deferredLoads.clear();
            if (configuration.getLocalCacheScope() == LocalCacheScope.STATEMENT) {
                clearLocalCache();
            }
        }
        return list;
    }
}
```

**职责总结**：
- 管理一级缓存（localCache）
- 处理延迟加载（deferredLoads）
- 委托给具体实现类执行查询
- 管理查询栈和缓存清理

### 6.3 设计模式应用深入分析

#### 工厂模式的应用

```java
// 1. SqlSessionFactory 工厂
public class DefaultSqlSessionFactory implements SqlSessionFactory {
    private final Configuration configuration;
    
    @Override
    public SqlSession openSession() {
        return openSessionFromDataSource(configuration.getDefaultExecutorType(), null, false);
    }
    
    private SqlSession openSessionFromDataSource(ExecutorType execType, TransactionIsolationLevel level, boolean autoCommit) {
        Transaction tx = null;
        try {
            final Environment environment = configuration.getEnvironment();
            final TransactionFactory transactionFactory = getTransactionFactoryFromEnvironment(environment);
            tx = transactionFactory.newTransaction(environment.getDataSource(), level, autoCommit);
            final Executor executor = configuration.newExecutor(tx, execType);
            return new DefaultSqlSession(configuration, executor, autoCommit);
        } catch (Exception e) {
            closeTransaction(tx);
            throw ExceptionFactory.wrapException("Error opening session.  Cause: " + e, e);
        }
    }
}

// 2. ObjectFactory 工厂
public class DefaultObjectFactory implements ObjectFactory {
    @Override
    public <T> T create(Class<T> type) {
        return create(type, null, null);
    }
    
    @Override
    public <T> T create(Class<T> type, List<Class<?>> constructorArgTypes, List<Object> constructorArgs) {
        Class<?> classToCreate = resolveInterface(type);
        return (T) instantiateClass(classToCreate, constructorArgTypes, constructorArgs);
    }
}
```

#### 代理模式的应用

```java
// Mapper 接口动态代理
public class MapperProxy<T> implements InvocationHandler, Serializable {
    private final SqlSession sqlSession;
    private final Class<T> mapperInterface;
    private final Map<Method, MapperMethod> methodCache;
    
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        try {
            if (Object.class.equals(method.getDeclaringClass())) {
                return method.invoke(this, args);
            } else if (isDefaultMethod(method)) {
                return invokeDefaultMethod(proxy, method, args);
            }
        } catch (Throwable t) {
            throw ExceptionUtil.unwrapThrowable(t);
        }
        final MapperMethod mapperMethod = cachedMapperMethod(method);
        return mapperMethod.execute(sqlSession, args);
    }
}
```

#### 装饰器模式的应用

```java
// 缓存装饰器
public class CachingExecutor implements Executor {
    private final Executor delegate;
    private final TransactionalCacheManager tcm = new TransactionalCacheManager();
    
    @Override
    public <E> List<E> query(MappedStatement ms, Object parameterObject, RowBounds rowBounds, 
                           ResultHandler resultHandler) throws SQLException {
        BoundSql boundSql = ms.getBoundSql(parameterObject);
        CacheKey key = createCacheKey(ms, parameterObject, rowBounds, boundSql);
        return query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);
    }
    
    @Override
    public <E> List<E> query(MappedStatement ms, Object parameterObject, RowBounds rowBounds, 
                           ResultHandler resultHandler, CacheKey key, BoundSql boundSql) throws SQLException {
        Cache cache = ms.getCache();
        if (cache != null) {
            flushCacheIfRequired(ms);
            if (ms.isUseCache() && resultHandler == null) {
                ensureNoOutParams(ms, boundSql);
                @SuppressWarnings("unchecked")
                List<E> list = (List<E>) tcm.getObject(cache, key);
                if (list == null) {
                    list = delegate.query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);
                    tcm.putObject(cache, key, list);
                }
                return list;
            }
        }
        return delegate.query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);
    }
}
```

### 6.4 性能优化机制分析

#### 连接池管理

```java
// 连接池配置
public class PooledDataSource implements DataSource {
    private final PoolState state = new PoolState(this);
    private final UnpooledDataSource dataSource;
    protected int poolMaximumActiveConnections = 10;
    protected int poolMaximumIdleConnections = 5;
    protected int poolMaximumCheckoutTime = 20000;
    protected int poolTimeToWait = 20000;
    protected String poolPingQuery = "NO PING QUERY SET";
    protected boolean poolPingEnabled = false;
    protected int poolPingConnectionsNotUsedFor = 0;
    
    // 获取连接
    @Override
    public Connection getConnection() throws SQLException {
        return popConnection(dataSource.getUsername(), dataSource.getPassword()).getProxyConnection();
    }
    
    // 归还连接
    public void pushConnection(PooledConnection conn) throws SQLException {
        synchronized (state) {
            state.activeConnections.remove(conn);
            if (conn.isValid()) {
                if (state.idleConnections.size() < poolMaximumIdleConnections && 
                    conn.getConnectionTypeCode() == expectedConnectionTypeCode) {
                    state.accumulatedCheckoutTime += conn.getCheckoutTime();
                    if (!conn.getRealConnection().getAutoCommit()) {
                        conn.getRealConnection().rollback();
                    }
                    PooledConnection newConn = new PooledConnection(conn.getRealConnection(), this);
                    state.idleConnections.add(newConn);
                    newConn.setCreatedTimestamp(conn.getCreatedTimestamp());
                    newConn.setLastUsedTimestamp(conn.getLastUsedTimestamp());
                    conn.invalidate();
                    state.notifyAll();
                } else {
                    state.accumulatedCheckoutTime += conn.getCheckoutTime();
                    conn.getRealConnection().close();
                    conn.invalidate();
                }
            } else {
                state.badConnectionCount++;
            }
        }
    }
}
```

#### 缓存机制

```java
// 一级缓存实现
public class PerpetualCache implements Cache {
    private final String id;
    private final Map<Object, Object> cache = new HashMap<>();
    
    @Override
    public void putObject(Object key, Object value) {
        cache.put(key, value);
    }
    
    @Override
    public Object getObject(Object key) {
        return cache.get(key);
    }
    
    @Override
    public Object removeObject(Object key) {
        return cache.remove(key);
    }
    
    @Override
    public void clear() {
        cache.clear();
    }
}

// 二级缓存实现
public class LruCache implements Cache {
    private final Cache delegate;
    private Map<Object, Object> keyMap;
    private Object eldestKey;
    
    public LruCache(Cache delegate) {
        this.delegate = delegate;
        setSize(1024);
    }
    
    @Override
    public void putObject(Object key, Object value) {
        delegate.putObject(key, value);
        cycleKeyList(key);
    }
    
    @Override
    public Object getObject(Object key) {
        keyMap.get(key);
        return delegate.getObject(key);
    }
}
```

## 总结

通过本文的深入学习，我们全面了解了 MyBatis 的整体架构设计：

1. **三层架构**：接口层、核心处理层、基础支持层，每层都有明确的职责分工
2. **核心组件**：SqlSession、Executor、StatementHandler、Configuration 等，各司其职
3. **组件协作**：通过接口进行协作，降低耦合度
4. **生命周期**：不同组件有不同的生命周期管理
5. **设计模式**：大量应用设计模式，提高代码质量
6. **性能优化**：连接池、缓存、预编译等机制提升性能

这种架构设计使得 MyBatis 既保持了简单易用的特性，又具备了良好的扩展性和性能。通过深入理解这些设计思想，我们可以更好地使用 MyBatis，也能够设计出更好的系统架构。

---

**思考题**：
1. 为什么 MyBatis 要采用三层架构设计？这种设计有什么优势？
2. 各个核心组件的职责分工有什么优势？如何保证组件间的协作？
3. 如何理解 MyBatis 的"半自动化"特性？这种特性有什么好处？
4. MyBatis 中应用了哪些设计模式？这些模式解决了什么问题？
5. 如何理解 MyBatis 的性能优化机制？这些机制是如何工作的？

